<?php
/**
 * Zend Framework
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://framework.zend.com/license/new-bsd
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@zend.com so we can send you a copy immediately.
 *
 * @copyright  Copyright (c) 2005-2011 Zend Technologies USA Inc. (http://www.zend.com)
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */


/* @source /library/Zend/Pdf/Canvas/Interface.php */
interface Zend_Pdf_Canvas_Interface { public function getResources(); public function getContents(); public function getHeight(); public function getWidth(); public function drawCanvas(Zend_Pdf_Canvas_Interface $canvas, $x1, $y1, $x2 = null, $y2 = null); public function setFillColor(Zend_Pdf_Color $color); public function setLineColor(Zend_Pdf_Color $color); public function setLineWidth($width); public function setLineDashingPattern($pattern, $phase = 0); public function setFont(Zend_Pdf_Resource_Font $font, $fontSize); public function setStyle(Zend_Pdf_Style $style); public function getFont(); public function getFontSize(); public function getStyle(); public function saveGS(); public function setAlpha($alpha, $mode = 'Normal'); public function clipCircle($x, $y, $radius, $startAngle = null, $endAngle = null); public function clipEllipse($x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null); public function clipPolygon($x, $y, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING); public function clipRectangle($x1, $y1, $x2, $y2); public function drawCircle($x, $y, $radius, $param4 = null, $param5 = null, $param6 = null); public function drawEllipse($x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null); public function drawImage(Zend_Pdf_Resource_Image $image, $x1, $y1, $x2, $y2); public function drawLayoutBox($box, $x, $y); public function drawLine($x1, $y1, $x2, $y2); public function drawPolygon($x, $y, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING); public function drawRectangle($x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE); public function drawRoundedRectangle($x1, $y1, $x2, $y2, $radius, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE); public function drawText($text, $x, $y, $charEncoding = ''); public function pathClose(); public function pathLine($x, $y); public function pathMove($x, $y); public function rotate($x, $y, $angle); public function scale($xScale, $yScale); public function translate($xShift, $yShift); public function skew($x, $y, $xAngle, $yAngle); public function rawWrite($data, $procSet = null); }

/* @source /library/Zend/Pdf/ElementFactory/Interface.php */
interface Zend_Pdf_ElementFactory_Interface { public function getFactory(); public function close(); public function resolve(); public function getId(); public function setObjectCount($objCount); public function getObjectCount(); public function attach(Zend_Pdf_ElementFactory_Interface $factory); public function calculateShift(Zend_Pdf_ElementFactory_Interface $factory); public function cleanEnumerationShiftCache(); public function getEnumerationShift(Zend_Pdf_ElementFactory_Interface $factory); public function markAsModified(Zend_Pdf_Element_Object $obj); public function remove(Zend_Pdf_Element_Object $obj); public function newObject(Zend_Pdf_Element $objectValue); public function newStreamObject($streamValue); public function listModifiedObjects($rootFactory = null); public function isModified(); }

/* @source /library/Zend/Pdf/Filter/Interface.php */
interface Zend_Pdf_Filter_Interface { public static function encode($data, $params = null); public static function decode($data, $params = null); }

/* @source /library/Zend/Pdf/Outline.php */
abstract class Zend_Pdf_Outline implements RecursiveIterator, Countable { protected $_open = false; public $childOutlines = array(); abstract public function getTitle(); abstract public function setTitle($title); public function isOpen() { return $this->_open; } public function setIsOpen($isOpen) { $this->_open = $isOpen; return $this; } abstract public function isItalic(); abstract public function setIsItalic($isItalic); abstract public function isBold(); abstract public function setIsBold($isBold); abstract public function getColor(); abstract public function setColor(Zend_Pdf_Color_Rgb $color); abstract public function getTarget(); abstract public function setTarget($target = null); public function getOptions() { return array('title' => $this->_title, 'open' => $this->_open, 'color' => $this->_color, 'italic' => $this->_italic, 'bold' => $this->_bold, 'target' => $this->_target); } public function setOptions(array $options) { foreach ($options as $key => $value) { switch ($key) { case 'title': $this->setTitle($value); break; case 'open': $this->setIsOpen($value); break; case 'color': $this->setColor($value); break; case 'italic': $this->setIsItalic($value); break; case 'bold': $this->setIsBold($value); break; case 'target': $this->setTarget($value); break; default: throw new Zend_Pdf_Exception("Unknown option name - '$key'."); break; } } return $this; } public static function create($param1, $param2 = null) { if (is_string($param1)) { if ($param2 !== null && !($param2 instanceof Zend_Pdf_Target || is_string($param2))) { throw new Zend_Pdf_Exception('Outline create method takes $title (string) and $target (Zend_Pdf_Target or string) or an array as an input'); } return new Zend_Pdf_Outline_Created(array('title' => $param1, 'target' => $param2)); } else { if (!is_array($param1) || $param2 !== null) { throw new Zend_Pdf_Exception('Outline create method takes $title (string) and $destination (Zend_Pdf_Destination) or an array as an input'); } return new Zend_Pdf_Outline_Created($param1); } } public function openOutlinesCount() { $count = 1; if ($this->isOpen()) { foreach ($this->childOutlines as $child) { $count += $child->openOutlinesCount(); } } return $count; } abstract public function dumpOutline(Zend_Pdf_ElementFactory_Interface $factory, $updateNavigation, Zend_Pdf_Element $parent, Zend_Pdf_Element $prev = null, SplObjectStorage $processedOutlines = null); public function current() { return current($this->childOutlines); } public function key() { return key($this->childOutlines); } public function next() { return next($this->childOutlines); } public function rewind() { return reset($this->childOutlines); } public function valid() { return current($this->childOutlines) !== false; } public function getChildren() { return current($this->childOutlines); } public function hasChildren() { return count($this->childOutlines) > 0; } public function count() { return count($this->childOutlines); } }

/* @source /library/Zend/Pdf/Resource.php */
abstract class Zend_Pdf_Resource { protected $_objectFactory; protected $_resource; public function __construct($resource) { if ($resource instanceof Zend_Pdf_Element_Object) { $this->_objectFactory = $resource->getFactory(); $this->_resource = $resource; return; } $this->_objectFactory = Zend_Pdf_ElementFactory::createFactory(1); if ($resource instanceof Zend_Pdf_Element) { $this->_resource = $this->_objectFactory->newObject($resource); } else { $this->_resource = $this->_objectFactory->newStreamObject($resource); } } public function __clone() { } public function cloneResource($factory, &$processed) { } public function getResource() { return $this->_resource; } public function getFactory() { return $this->_objectFactory; } }

/* @source /library/Zend/Pdf/Target.php */
abstract class Zend_Pdf_Target { public static function load(Zend_Pdf_Element $resource) { if ($resource->getType() == Zend_Pdf_Element::TYPE_DICTIONARY) { if (($resource->Type === null || $resource->Type->value =='Action') && $resource->S !== null) { return Zend_Pdf_Action::load($resource); } else if ($resource->D !== null) { $resource = $resource->D; } else { throw new Zend_Pdf_Exception('Wrong resource type.'); } } if ($resource->getType() == Zend_Pdf_Element::TYPE_ARRAY || $resource->getType() == Zend_Pdf_Element::TYPE_NAME || $resource->getType() == Zend_Pdf_Element::TYPE_STRING) { return Zend_Pdf_Destination::load($resource); } else { throw new Zend_Pdf_Exception( 'Wrong resource type.' ); } } abstract public function getResource(); }

/* @source /library/Zend/Pdf/FileParser.php */
abstract class Zend_Pdf_FileParser { const BYTE_ORDER_LITTLE_ENDIAN = 0; const BYTE_ORDER_BIG_ENDIAN = 1; protected $_isScreened = false; protected $_isParsed = false; protected $_dataSource = null; abstract public function screen(); abstract public function parse(); public function __construct(Zend_Pdf_FileParserDataSource $dataSource) { if ($dataSource->getSize() == 0) { throw new Zend_Pdf_Exception('The data source has not been properly initialized', Zend_Pdf_Exception::BAD_DATA_SOURCE); } $this->_dataSource = $dataSource; } public function __destruct() { $this->_dataSource = null; } public function isScreened() { return $this->_isScreened; } public function isParsed() { return $this->_isParsed; } public function getDataSource() { return $this->_dataSource; } public function moveToOffset($offset) { $this->_dataSource->moveToOffset($offset); } public function getOffset() { return $this->_dataSource->getOffset(); } public function getSize() { return $this->_dataSource->getSize(); } public function readBytes($byteCount) { return $this->_dataSource->readBytes($byteCount); } public function skipBytes($byteCount) { $this->_dataSource->skipBytes($byteCount); } public function readInt($size, $byteOrder = Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { if (($size < 1) || ($size > 4)) { throw new Zend_Pdf_Exception("Invalid signed integer size: $size", Zend_Pdf_Exception::INVALID_INTEGER_SIZE); } $bytes = $this->_dataSource->readBytes($size); if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { $number = ord($bytes[0]); if (($number & 0x80) == 0x80) { $number = (~ $number) & 0xff; for ($i = 1; $i < $size; $i++) { $number = ($number << 8) | ((~ ord($bytes[$i])) & 0xff); } $number = ~$number; } else { for ($i = 1; $i < $size; $i++) { $number = ($number << 8) | ord($bytes[$i]); } } } else if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_LITTLE_ENDIAN) { $number = ord($bytes[$size - 1]); if (($number & 0x80) == 0x80) { $number = 0; for ($i = --$size; $i >= 0; $i--) { $number |= ((~ ord($bytes[$i])) & 0xff) << ($i * 8); } $number = ~$number; } else { $number = 0; for ($i = --$size; $i >= 0; $i--) { $number |= ord($bytes[$i]) << ($i * 8); } } } else { throw new Zend_Pdf_Exception("Invalid byte order: $byteOrder", Zend_Pdf_Exception::INVALID_BYTE_ORDER); } return $number; } public function readUInt($size, $byteOrder = Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { if (($size < 1) || ($size > 4)) { throw new Zend_Pdf_Exception("Invalid unsigned integer size: $size", Zend_Pdf_Exception::INVALID_INTEGER_SIZE); } $bytes = $this->_dataSource->readBytes($size); if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { $number = ord($bytes[0]); for ($i = 1; $i < $size; $i++) { $number = ($number << 8) | ord($bytes[$i]); } } else if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_LITTLE_ENDIAN) { $number = 0; for ($i = --$size; $i >= 0; $i--) { $number |= ord($bytes[$i]) << ($i * 8); } } else { throw new Zend_Pdf_Exception("Invalid byte order: $byteOrder", Zend_Pdf_Exception::INVALID_BYTE_ORDER); } return $number; } public function isBitSet($bit, $bitField) { $bitMask = 1 << $bit; $isSet = (($bitField & $bitMask) == $bitMask); return $isSet; } public function readFixed($mantissaBits, $fractionBits, $byteOrder = Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { $bitsToRead = $mantissaBits + $fractionBits; if (($bitsToRead % 8) !== 0) { throw new Zend_Pdf_Exception('Fixed-point numbers are whole bytes', Zend_Pdf_Exception::BAD_FIXED_POINT_SIZE); } $number = $this->readInt(($bitsToRead >> 3), $byteOrder) / (1 << $fractionBits); return $number; } public function readStringUTF16($byteCount, $byteOrder = Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN, $characterSet = '') { if ($byteCount == 0) { return ''; } $bytes = $this->_dataSource->readBytes($byteCount); if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN) { if ($characterSet == 'UTF-16BE') { return $bytes; } return iconv('UTF-16BE', $characterSet, $bytes); } else if ($byteOrder == Zend_Pdf_FileParser::BYTE_ORDER_LITTLE_ENDIAN) { if ($characterSet == 'UTF-16LE') { return $bytes; } return iconv('UTF-16LE', $characterSet, $bytes); } else { throw new Zend_Pdf_Exception("Invalid byte order: $byteOrder", Zend_Pdf_Exception::INVALID_BYTE_ORDER); } } public function readStringMacRoman($byteCount, $characterSet = '') { if ($byteCount == 0) { return ''; } $bytes = $this->_dataSource->readBytes($byteCount); if ($characterSet == 'MacRoman') { return $bytes; } return iconv('MacRoman', $characterSet, $bytes); } public function readStringPascal($characterSet = '', $lengthBytes = 1) { $byteCount = $this->readUInt($lengthBytes); if ($byteCount == 0) { return ''; } $bytes = $this->_dataSource->readBytes($byteCount); if ($characterSet == 'ASCII') { return $bytes; } return iconv('ASCII', $characterSet, $bytes); } }

/* @source /library/Zend/Pdf/Annotation.php */
abstract class Zend_Pdf_Annotation { protected $_annotationDictionary; public function getResource() { return $this->_annotationDictionary; } public function setBottom($bottom) { $this->_annotationDictionary->Rect->items[1]->touch(); $this->_annotationDictionary->Rect->items[1]->value = $bottom; return $this; } public function getBottom() { return $this->_annotationDictionary->Rect->items[1]->value; } public function setTop($top) { $this->_annotationDictionary->Rect->items[3]->touch(); $this->_annotationDictionary->Rect->items[3]->value = $top; return $this; } public function getTop() { return $this->_annotationDictionary->Rect->items[3]->value; } public function setRight($right) { $this->_annotationDictionary->Rect->items[2]->touch(); $this->_annotationDictionary->Rect->items[2]->value = $right; return $this; } public function getRight() { return $this->_annotationDictionary->Rect->items[2]->value; } public function setLeft($left) { $this->_annotationDictionary->Rect->items[0]->touch(); $this->_annotationDictionary->Rect->items[0]->value = $left; return $this; } public function getLeft() { return $this->_annotationDictionary->Rect->items[0]->value; } public function getText() { if ($this->_annotationDictionary->Contents === null) { return ''; } return $this->_annotationDictionary->Contents->value; } public function setText($text) { if ($this->_annotationDictionary->Contents === null) { $this->_annotationDictionary->touch(); $this->_annotationDictionary->Contents = new Zend_Pdf_Element_String($text); } else { $this->_annotationDictionary->Contents->touch(); $this->_annotationDictionary->Contents->value = new Zend_Pdf_Element_String($text); } return $this; } public function __construct(Zend_Pdf_Element $annotationDictionary) { if ($annotationDictionary->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Annotation dictionary resource has to be a dictionary.'); } $this->_annotationDictionary = $annotationDictionary; if ($this->_annotationDictionary->Type !== null && $this->_annotationDictionary->Type->value != 'Annot') { throw new Zend_Pdf_Exception('Wrong resource type. \'Annot\' expected.'); } if ($this->_annotationDictionary->Rect === null) { throw new Zend_Pdf_Exception('\'Rect\' dictionary entry is required.'); } if (count($this->_annotationDictionary->Rect->items) != 4 || $this->_annotationDictionary->Rect->items[0]->getType() != Zend_Pdf_Element::TYPE_NUMERIC || $this->_annotationDictionary->Rect->items[1]->getType() != Zend_Pdf_Element::TYPE_NUMERIC || $this->_annotationDictionary->Rect->items[2]->getType() != Zend_Pdf_Element::TYPE_NUMERIC || $this->_annotationDictionary->Rect->items[3]->getType() != Zend_Pdf_Element::TYPE_NUMERIC ) { throw new Zend_Pdf_Exception('\'Rect\' dictionary entry must be an array of four numeric elements.'); } } public static function load(Zend_Pdf_Element $resource) { } }

/* @source /library/Zend/Pdf/Image.php */
abstract class Zend_Pdf_Image { const TYPE_UNKNOWN = 0; const TYPE_JPEG = 1; const TYPE_PNG = 2; const TYPE_TIFF = 3; const TIFF_FIELD_TYPE_BYTE=1; const TIFF_FIELD_TYPE_ASCII=2; const TIFF_FIELD_TYPE_SHORT=3; const TIFF_FIELD_TYPE_LONG=4; const TIFF_FIELD_TYPE_RATIONAL=5; const TIFF_TAG_IMAGE_WIDTH=256; const TIFF_TAG_IMAGE_LENGTH=257; const TIFF_TAG_BITS_PER_SAMPLE=258; const TIFF_TAG_COMPRESSION=259; const TIFF_TAG_PHOTOMETRIC_INTERPRETATION=262; const TIFF_TAG_STRIP_OFFSETS=273; const TIFF_TAG_SAMPLES_PER_PIXEL=277; const TIFF_TAG_STRIP_BYTE_COUNTS=279; const TIFF_COMPRESSION_UNCOMPRESSED = 1; const TIFF_COMPRESSION_CCITT1D = 2; const TIFF_COMPRESSION_GROUP_3_FAX = 3; const TIFF_COMPRESSION_GROUP_4_FAX = 4; const TIFF_COMPRESSION_LZW = 5; const TIFF_COMPRESSION_JPEG = 6; const TIFF_COMPRESSION_FLATE = 8; const TIFF_COMPRESSION_FLATE_OBSOLETE_CODE = 32946; const TIFF_COMPRESSION_PACKBITS = 32773; const TIFF_PHOTOMETRIC_INTERPRETATION_WHITE_IS_ZERO=0; const TIFF_PHOTOMETRIC_INTERPRETATION_BLACK_IS_ZERO=1; const TIFF_PHOTOMETRIC_INTERPRETATION_RGB=2; const TIFF_PHOTOMETRIC_INTERPRETATION_RGB_INDEXED=3; const TIFF_PHOTOMETRIC_INTERPRETATION_CMYK=5; const TIFF_PHOTOMETRIC_INTERPRETATION_YCBCR=6; const TIFF_PHOTOMETRIC_INTERPRETATION_CIELAB=8; const PNG_COMPRESSION_DEFAULT_STRATEGY = 0; const PNG_COMPRESSION_FILTERED = 1; const PNG_COMPRESSION_HUFFMAN_ONLY = 2; const PNG_COMPRESSION_RLE = 3; const PNG_FILTER_NONE = 0; const PNG_FILTER_SUB = 1; const PNG_FILTER_UP = 2; const PNG_FILTER_AVERAGE = 3; const PNG_FILTER_PAETH = 4; const PNG_INTERLACING_DISABLED = 0; const PNG_INTERLACING_ENABLED = 1; const PNG_CHANNEL_GRAY = 0; const PNG_CHANNEL_RGB = 2; const PNG_CHANNEL_INDEXED = 3; const PNG_CHANNEL_GRAY_ALPHA = 4; const PNG_CHANNEL_RGB_ALPHA = 6; public static function imageWithPath($filePath) { return Zend_Pdf_Resource_ImageFactory::factory($filePath); $dataSource = new Zend_Pdf_FileParserDataSource_File($filePath); $fileExtension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION)); switch ($fileExtension) { case 'tif': case 'tiff': $image = Zend_Pdf_Image::_extractTiffImage($dataSource); break; case 'png': $image = Zend_Pdf_Image::_extractPngImage($dataSource); break; case 'jpg': case 'jpe': case 'jpeg': $image = Zend_Pdf_Image::_extractJpegImage($dataSource); break; default: throw new Zend_Pdf_Exception("Cannot create image resource. File extension not known or unsupported type."); break; } $dataSource = null; if ($image !== null) { return $image; } else { throw new Zend_Pdf_Exception("Cannot determine image type: $filePath", Zend_Pdf_Exception::CANT_DETERMINE_IMAGE_TYPE); } } protected static function _extractJpegImage($dataSource) { throw new Zend_Pdf_Exception('Jpeg image fileparser is not implemented. Old styly implementation has to be used.'); $imageParser = new Zend_Pdf_FileParser_Image_Jpeg($dataSource); $image = new Zend_Pdf_Resource_Image_Jpeg($imageParser); unset($imageParser); return $image; } protected static function _extractPngImage($dataSource) { $imageParser = new Zend_Pdf_FileParser_Image_Png($dataSource); $image = new Zend_Pdf_Resource_Image_Png($imageParser); unset($imageParser); return $image; } protected static function _extractTiffImage($dataSource) { throw new Zend_Pdf_Exception('Tiff image fileparser is not implemented. Old styly implementation has to be used.'); $imageParser = new Zend_Pdf_FileParser_Image_Tiff($dataSource); $image = new Zend_Pdf_Resource_Image_Tiff($imageParser); unset($imageParser); return $image; } }

/* @source /library/Zend/Pdf/Element.php */
abstract class Zend_Pdf_Element { const TYPE_BOOL = 1; const TYPE_NUMERIC = 2; const TYPE_STRING = 3; const TYPE_NAME = 4; const TYPE_ARRAY = 5; const TYPE_DICTIONARY = 6; const TYPE_STREAM = 7; const TYPE_NULL = 11; private $_parentObject = null; abstract public function getType(); abstract public function toString($factory = null); const CLONE_MODE_SKIP_PAGES = 1; const CLONE_MODE_FORCE_CLONING = 2; public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { return clone $this; } public function setParentObject(Zend_Pdf_Element_Object $parent) { $this->_parentObject = $parent; } public function getParentObject() { return $this->_parentObject; } public function touch() { if ($this->_parentObject !== null) { $this->_parentObject->touch(); } } public function cleanUp() { } public function toPhp() { return $this->value; } public static function phpToPdf($input) { if (is_numeric($input)) { return new Zend_Pdf_Element_Numeric($input); } else if (is_bool($input)) { return new Zend_Pdf_Element_Boolean($input); } else if (is_array($input)) { $pdfElementsArray = array(); $isDictionary = false; foreach ($input as $key => $value) { if (is_string($key)) { $isDictionary = true; } $pdfElementsArray[$key] = Zend_Pdf_Element::phpToPdf($value); } if ($isDictionary) { return new Zend_Pdf_Element_Dictionary($pdfElementsArray); } else { return new Zend_Pdf_Element_Array($pdfElementsArray); } } else { return new Zend_Pdf_Element_String((string)$input); } } }

/* @source /library/Zend/Pdf/Font.php */
abstract class Zend_Pdf_Font { const TYPE_UNKNOWN = 0; const TYPE_STANDARD = 1; const TYPE_TYPE_1 = 2; const TYPE_TRUETYPE = 3; const TYPE_TYPE_0 = 4; const TYPE_CIDFONT_TYPE_0 = 5; const TYPE_CIDFONT_TYPE_2 = 6; const FONT_COURIER = 'Courier'; const FONT_COURIER_BOLD = 'Courier-Bold'; const FONT_COURIER_OBLIQUE = 'Courier-Oblique'; const FONT_COURIER_ITALIC = 'Courier-Oblique'; const FONT_COURIER_BOLD_OBLIQUE = 'Courier-BoldOblique'; const FONT_COURIER_BOLD_ITALIC = 'Courier-BoldOblique'; const FONT_HELVETICA = 'Helvetica'; const FONT_HELVETICA_BOLD = 'Helvetica-Bold'; const FONT_HELVETICA_OBLIQUE = 'Helvetica-Oblique'; const FONT_HELVETICA_ITALIC = 'Helvetica-Oblique'; const FONT_HELVETICA_BOLD_OBLIQUE = 'Helvetica-BoldOblique'; const FONT_HELVETICA_BOLD_ITALIC = 'Helvetica-BoldOblique'; const FONT_SYMBOL = 'Symbol'; const FONT_TIMES_ROMAN = 'Times-Roman'; const FONT_TIMES = 'Times-Roman'; const FONT_TIMES_BOLD = 'Times-Bold'; const FONT_TIMES_ITALIC = 'Times-Italic'; const FONT_TIMES_BOLD_ITALIC = 'Times-BoldItalic'; const FONT_ZAPFDINGBATS = 'ZapfDingbats'; const NAME_COPYRIGHT = 0; const NAME_FAMILY = 1; const NAME_STYLE = 2; const NAME_ID = 3; const NAME_FULL = 4; const NAME_VERSION = 5; const NAME_POSTSCRIPT = 6; const NAME_TRADEMARK = 7; const NAME_MANUFACTURER = 8; const NAME_DESIGNER = 9; const NAME_DESCRIPTION = 10; const NAME_VENDOR_URL = 11; const NAME_DESIGNER_URL = 12; const NAME_LICENSE = 13; const NAME_LICENSE_URL = 14; const NAME_PREFERRED_FAMILY = 16; const NAME_PREFERRED_STYLE = 17; const NAME_SAMPLE_TEXT = 19; const NAME_CID_NAME = 20; const WEIGHT_THIN = 100; const WEIGHT_EXTRA_LIGHT = 200; const WEIGHT_LIGHT = 300; const WEIGHT_NORMAL = 400; const WEIGHT_MEDIUM = 500; const WEIGHT_SEMI_BOLD = 600; const WEIGHT_BOLD = 700; const WEIGHT_EXTRA_BOLD = 800; const WEIGHT_BLACK = 900; const WIDTH_ULTRA_CONDENSED = 1; const WIDTH_EXTRA_CONDENSED = 2; const WIDTH_CONDENSED = 3; const WIDTH_SEMI_CONDENSED = 4; const WIDTH_NORMAL = 5; const WIDTH_SEMI_EXPANDED = 6; const WIDTH_EXPANDED = 7; const WIDTH_EXTRA_EXPANDED = 8; const WIDTH_ULTRA_EXPANDED = 9; const EMBED_DONT_EMBED = 0x01; const EMBED_DONT_SUBSET = 0x02; const EMBED_DONT_COMPRESS = 0x04; const EMBED_SUPPRESS_EMBED_EXCEPTION = 0x08; private static $_fontNames = array(); private static $_fontFilePaths = array(); public static function fontWithName($name, $embeddingOptions = 0) { if (isset(Zend_Pdf_Font::$_fontNames[$name])) { return Zend_Pdf_Font::$_fontNames[$name]; } switch ($name) { case Zend_Pdf_Font::FONT_COURIER: $font = new Zend_Pdf_Resource_Font_Simple_Standard_Courier(); break; case Zend_Pdf_Font::FONT_COURIER_BOLD: $font = new Zend_Pdf_Resource_Font_Simple_Standard_CourierBold(); break; case Zend_Pdf_Font::FONT_COURIER_OBLIQUE: $font = new Zend_Pdf_Resource_Font_Simple_Standard_CourierOblique(); break; case Zend_Pdf_Font::FONT_COURIER_BOLD_OBLIQUE: $font = new Zend_Pdf_Resource_Font_Simple_Standard_CourierBoldOblique(); break; case Zend_Pdf_Font::FONT_HELVETICA: $font = new Zend_Pdf_Resource_Font_Simple_Standard_Helvetica(); break; case Zend_Pdf_Font::FONT_HELVETICA_BOLD: $font = new Zend_Pdf_Resource_Font_Simple_Standard_HelveticaBold(); break; case Zend_Pdf_Font::FONT_HELVETICA_OBLIQUE: $font = new Zend_Pdf_Resource_Font_Simple_Standard_HelveticaOblique(); break; case Zend_Pdf_Font::FONT_HELVETICA_BOLD_OBLIQUE: $font = new Zend_Pdf_Resource_Font_Simple_Standard_HelveticaBoldOblique(); break; case Zend_Pdf_Font::FONT_SYMBOL: $font = new Zend_Pdf_Resource_Font_Simple_Standard_Symbol(); break; case Zend_Pdf_Font::FONT_TIMES_ROMAN: $font = new Zend_Pdf_Resource_Font_Simple_Standard_TimesRoman(); break; case Zend_Pdf_Font::FONT_TIMES_BOLD: $font = new Zend_Pdf_Resource_Font_Simple_Standard_TimesBold(); break; case Zend_Pdf_Font::FONT_TIMES_ITALIC: $font = new Zend_Pdf_Resource_Font_Simple_Standard_TimesItalic(); break; case Zend_Pdf_Font::FONT_TIMES_BOLD_ITALIC: $font = new Zend_Pdf_Resource_Font_Simple_Standard_TimesBoldItalic(); break; case Zend_Pdf_Font::FONT_ZAPFDINGBATS: $font = new Zend_Pdf_Resource_Font_Simple_Standard_ZapfDingbats(); break; default: throw new Zend_Pdf_Exception("Unknown font name: $name", Zend_Pdf_Exception::BAD_FONT_NAME); } Zend_Pdf_Font::$_fontNames[$name] = $font; return $font; } public static function fontWithPath($filePath, $embeddingOptions = 0) { $filePathKey = md5($filePath); if (isset(Zend_Pdf_Font::$_fontFilePaths[$filePathKey])) { return Zend_Pdf_Font::$_fontFilePaths[$filePathKey]; } $dataSource = new Zend_Pdf_FileParserDataSource_File($filePath); $fileExtension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION)); switch ($fileExtension) { case 'ttf': $font = Zend_Pdf_Font::_extractTrueTypeFont($dataSource, $embeddingOptions); break; default: $font = null; break; } if ($font === null) { if (($font === null) && ($fileExtension != 'ttf')) { $font = Zend_Pdf_Font::_extractTrueTypeFont($dataSource, $embeddingOptions); } } $dataSource = null; if ($font !== null) { $fontName = $font->getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, '', ''); Zend_Pdf_Font::$_fontNames[$fontName] = $font; $filePathKey = md5($filePath); Zend_Pdf_Font::$_fontFilePaths[$filePathKey] = $font; return $font; } else { throw new Zend_Pdf_Exception("Cannot determine font type: $filePath", Zend_Pdf_Exception::CANT_DETERMINE_FONT_TYPE); } } protected static function _extractTrueTypeFont($dataSource, $embeddingOptions) { try { $fontParser = new Zend_Pdf_FileParser_Font_OpenType_TrueType($dataSource); $fontParser->parse(); if ($fontParser->isAdobeLatinSubset) { $font = new Zend_Pdf_Resource_Font_Simple_Parsed_TrueType($fontParser, $embeddingOptions); } else { $cidFont = new Zend_Pdf_Resource_Font_CidFont_TrueType($fontParser, $embeddingOptions); $font = new Zend_Pdf_Resource_Font_Type0($cidFont); } } catch (Zend_Pdf_Exception $e) { $fontParser = null; switch ($e->getCode()) { case Zend_Pdf_Exception::WRONG_FONT_TYPE: case Zend_Pdf_Exception::BAD_TABLE_COUNT: case Zend_Pdf_Exception::BAD_MAGIC_NUMBER: return null; default: throw new Zend_Pdf_Exception($e->getMessage(), $e->getCode(), $e); } } return $font; } }

/* @source /library/Zend/Pdf/Color.php */
abstract class Zend_Pdf_Color { abstract public function instructions($stroking); abstract public function getComponents(); }

/* @source /library/Zend/Pdf/Trailer.php */
abstract class Zend_Pdf_Trailer { private static $_allowedKeys = array('Size', 'Prev', 'Root', 'Encrypt', 'Info', 'ID', 'Index', 'W', 'XRefStm', 'DocChecksum'); private $_dict; private function _checkDictKey($key) { if ( !in_array($key, self::$_allowedKeys) ) { throw new Zend_Pdf_Exception("Unknown trailer dictionary key: '$key'."); } } public function __construct(Zend_Pdf_Element_Dictionary $dict) { $this->_dict = $dict; foreach ($this->_dict->getKeys() as $dictKey) { $this->_checkDictKey($dictKey); } } public function __get($property) { return $this->_dict->$property; } public function __set($property, $value) { $this->_checkDictKey($property); $this->_dict->$property = $value; } public function toString() { return "trailer\n" . $this->_dict->toString() . "\n"; } abstract public function getPDFLength(); abstract public function getPDFString(); abstract public function getLastFreeObject(); }

/* @source /library/Zend/Pdf/Action.php */
abstract class Zend_Pdf_Action extends Zend_Pdf_Target implements RecursiveIterator, Countable { protected $_actionDictionary; protected $_originalNextList; public $next = array(); public function __construct(Zend_Pdf_Element $dictionary, SplObjectStorage $processedActions) { if ($dictionary->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('$dictionary mast be a direct or an indirect dictionary object.'); } $this->_actionDictionary = $dictionary; if ($dictionary->Next !== null) { if ($dictionary->Next instanceof Zend_Pdf_Element_Dictionary) { if (!$processedActions->contains($dictionary->Next)) { $processedActions->attach($dictionary->Next); $this->next[] = Zend_Pdf_Action::load($dictionary->Next, $processedActions); } } else if ($dictionary->Next instanceof Zend_Pdf_Element_Array) { foreach ($dictionary->Next->items as $chainedActionDictionary) { if (!$processedActions->contains($chainedActionDictionary)) { $processedActions->attach($chainedActionDictionary); $this->next[] = Zend_Pdf_Action::load($chainedActionDictionary, $processedActions); } } } else { throw new Zend_Pdf_Exception('PDF Action dictionary Next entry must be a dictionary or an array.'); } } $this->_originalNextList = $this->next; } public static function load(Zend_Pdf_Element $dictionary, SplObjectStorage $processedActions = null) { if ($processedActions === null) { $processedActions = new SplObjectStorage(); } if ($dictionary->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('$dictionary mast be a direct or an indirect dictionary object.'); } if (isset($dictionary->Type) && $dictionary->Type->value != 'Action') { throw new Zend_Pdf_Exception('Action dictionary Type entry must be set to \'Action\'.'); } if ($dictionary->S === null) { throw new Zend_Pdf_Exception('Action dictionary must contain S entry'); } switch ($dictionary->S->value) { case 'GoTo': return new Zend_Pdf_Action_GoTo($dictionary, $processedActions); break; case 'GoToR': return new Zend_Pdf_Action_GoToR($dictionary, $processedActions); break; case 'GoToE': return new Zend_Pdf_Action_GoToE($dictionary, $processedActions); break; case 'Launch': return new Zend_Pdf_Action_Launch($dictionary, $processedActions); break; case 'Thread': return new Zend_Pdf_Action_Thread($dictionary, $processedActions); break; case 'URI': return new Zend_Pdf_Action_URI($dictionary, $processedActions); break; case 'Sound': return new Zend_Pdf_Action_Sound($dictionary, $processedActions); break; case 'Movie': return new Zend_Pdf_Action_Movie($dictionary, $processedActions); break; case 'Hide': return new Zend_Pdf_Action_Hide($dictionary, $processedActions); break; case 'Named': return new Zend_Pdf_Action_Named($dictionary, $processedActions); break; case 'SubmitForm': return new Zend_Pdf_Action_SubmitForm($dictionary, $processedActions); break; case 'ResetForm': return new Zend_Pdf_Action_ResetForm($dictionary, $processedActions); break; case 'ImportData': return new Zend_Pdf_Action_ImportData($dictionary, $processedActions); break; case 'JavaScript': return new Zend_Pdf_Action_JavaScript($dictionary, $processedActions); break; case 'SetOCGState': return new Zend_Pdf_Action_SetOCGState($dictionary, $processedActions); break; case 'Rendition': return new Zend_Pdf_Action_Rendition($dictionary, $processedActions); break; case 'Trans': return new Zend_Pdf_Action_Trans($dictionary, $processedActions); break; case 'GoTo3DView': return new Zend_Pdf_Action_GoTo3DView($dictionary, $processedActions); break; default: return new Zend_Pdf_Action_Unknown($dictionary, $processedActions); break; } } public function getResource() { return $this->_actionDictionary; } public function dumpAction(Zend_Pdf_ElementFactory_Interface $factory, SplObjectStorage $processedActions = null) { if ($processedActions === null) { $processedActions = new SplObjectStorage(); } if ($processedActions->contains($this)) { throw new Zend_Pdf_Exception('Action chain cyclyc reference is detected.'); } $processedActions->attach($this); $childListUpdated = false; if (count($this->_originalNextList) != count($this->next)) { $childListUpdated = true; } else if ( !(array_keys($this->_originalNextList) === array_keys($this->next)) ) { $childListUpdated = true; } else { foreach ($this->next as $key => $childAction) { if ($this->_originalNextList[$key] !== $childAction) { $childListUpdated = true; break; } } } if ($childListUpdated) { $this->_actionDictionary->touch(); switch (count($this->next)) { case 0: $this->_actionDictionary->Next = null; break; case 1: $child = reset($this->next); $this->_actionDictionary->Next = $child->dumpAction($factory, $processedActions); break; default: $pdfChildArray = new Zend_Pdf_Element_Array(); foreach ($this->next as $child) { $pdfChildArray->items[] = $child->dumpAction($factory, $processedActions); } $this->_actionDictionary->Next = $pdfChildArray; break; } } else { foreach ($this->next as $child) { $child->dumpAction($factory, $processedActions); } } if ($this->_actionDictionary instanceof Zend_Pdf_Element_Dictionary) { return $factory->newObject($this->_actionDictionary); } else { return $this->_actionDictionary; } } public function current() { return current($this->next); } public function key() { return key($this->next); } public function next() { return next($this->next); } public function rewind() { return reset($this->next); } public function valid() { return current($this->next) !== false; } public function getChildren() { return current($this->next); } public function hasChildren() { return count($this->next) > 0; } public function count() { return count($this->childOutlines); } }

/* @source /library/Zend/Pdf/Cmap.php */
abstract class Zend_Pdf_Cmap { const TYPE_BYTE_ENCODING = 0x00; const TYPE_HIGH_BYTE_MAPPING = 0x02; const TYPE_SEGMENT_TO_DELTA = 0x04; const TYPE_TRIMMED_TABLE = 0x06; const TYPE_MIXED_COVERAGE = 0x08; const TYPE_TRIMMED_ARRAY = 0x0a; const TYPE_SEGMENTED_COVERAGE = 0x0c; const TYPE_BYTE_ENCODING_STATIC = 0xf1; const TYPE_UNKNOWN = 0xff; const MISSING_CHARACTER_GLYPH = 0x00; public static function cmapWithTypeData($cmapType, $cmapData) { switch ($cmapType) { case Zend_Pdf_Cmap::TYPE_BYTE_ENCODING: return new Zend_Pdf_Cmap_ByteEncoding($cmapData); case Zend_Pdf_Cmap::TYPE_BYTE_ENCODING_STATIC: return new Zend_Pdf_Cmap_ByteEncoding_Static($cmapData); case Zend_Pdf_Cmap::TYPE_HIGH_BYTE_MAPPING: throw new Zend_Pdf_Exception('High byte mapping cmap currently unsupported', Zend_Pdf_Exception::CMAP_TYPE_UNSUPPORTED); case Zend_Pdf_Cmap::TYPE_SEGMENT_TO_DELTA: return new Zend_Pdf_Cmap_SegmentToDelta($cmapData); case Zend_Pdf_Cmap::TYPE_TRIMMED_TABLE: return new Zend_Pdf_Cmap_TrimmedTable($cmapData); case Zend_Pdf_Cmap::TYPE_MIXED_COVERAGE: throw new Zend_Pdf_Exception('Mixed coverage cmap currently unsupported', Zend_Pdf_Exception::CMAP_TYPE_UNSUPPORTED); case Zend_Pdf_Cmap::TYPE_TRIMMED_ARRAY: throw new Zend_Pdf_Exception('Trimmed array cmap currently unsupported', Zend_Pdf_Exception::CMAP_TYPE_UNSUPPORTED); case Zend_Pdf_Cmap::TYPE_SEGMENTED_COVERAGE: throw new Zend_Pdf_Exception('Segmented coverage cmap currently unsupported', Zend_Pdf_Exception::CMAP_TYPE_UNSUPPORTED); default: throw new Zend_Pdf_Exception("Unknown cmap type: $cmapType", Zend_Pdf_Exception::CMAP_UNKNOWN_TYPE); } } abstract public function __construct($cmapData); abstract public function glyphNumbersForCharacters($characterCodes); abstract public function glyphNumberForCharacter($characterCode); abstract public function getCoveredCharacters(); abstract public function getCoveredCharactersGlyphs(); protected function _extractInt2(&$data, $index) { if (($index < 0) | (($index + 1) > strlen($data))) { throw new Zend_Pdf_Exception("Index out of range: $index", Zend_Pdf_Exception::INDEX_OUT_OF_RANGE); } $number = ord($data[$index]); if (($number & 0x80) == 0x80) { $number = ~((((~ $number) & 0xff) << 8) | ((~ ord($data[++$index])) & 0xff)); } else { $number = ($number << 8) | ord($data[++$index]); } return $number; } protected function _extractUInt2(&$data, $index) { if (($index < 0) | (($index + 1) > strlen($data))) { throw new Zend_Pdf_Exception("Index out of range: $index", Zend_Pdf_Exception::INDEX_OUT_OF_RANGE); } $number = (ord($data[$index]) << 8) | ord($data[++$index]); return $number; } protected function _extractUInt4(&$data, $index) { if (($index < 0) | (($index + 3) > strlen($data))) { throw new Zend_Pdf_Exception("Index out of range: $index", Zend_Pdf_Exception::INDEX_OUT_OF_RANGE); } $number = (ord($data[$index]) << 24) | (ord($data[++$index]) << 16) | (ord($data[++$index]) << 8) | ord($data[++$index]); return $number; } }

/* @source /library/Zend/Pdf/FileParserDataSource.php */
abstract class Zend_Pdf_FileParserDataSource { protected $_size = 0; protected $_offset = 0; abstract public function __destruct(); abstract public function readBytes($byteCount); abstract public function readAllBytes(); public function __toString() { return get_class($this); } public function getOffset() { return $this->_offset; } public function getSize() { return $this->_size; } public function moveToOffset($offset) { if ($this->_offset == $offset) { return; } if ($offset < 0) { throw new Zend_Pdf_Exception('Attempt to move before start of data source', Zend_Pdf_Exception::MOVE_BEFORE_START_OF_FILE); } if ($offset >= $this->_size) { throw new Zend_Pdf_Exception('Attempt to move beyond end of data source', Zend_Pdf_Exception::MOVE_BEYOND_END_OF_FILE); } $this->_offset = $offset; } public function skipBytes($byteCount) { $this->moveToOffset($this->_offset + $byteCount); } }

/* @source /library/Zend/Pdf/Destination.php */
abstract class Zend_Pdf_Destination extends Zend_Pdf_Target { public static function load(Zend_Pdf_Element $resource) { if ($resource->getType() == Zend_Pdf_Element::TYPE_NAME || $resource->getType() == Zend_Pdf_Element::TYPE_STRING) { return new Zend_Pdf_Destination_Named($resource); } if ($resource->getType() != Zend_Pdf_Element::TYPE_ARRAY) { throw new Zend_Pdf_Exception('An explicit destination must be a direct or an indirect array object.'); } if (count($resource->items) < 2) { throw new Zend_Pdf_Exception('An explicit destination array must contain at least two elements.'); } switch ($resource->items[1]->value) { case 'XYZ': return new Zend_Pdf_Destination_Zoom($resource); break; case 'Fit': return new Zend_Pdf_Destination_Fit($resource); break; case 'FitH': return new Zend_Pdf_Destination_FitHorizontally($resource); break; case 'FitV': return new Zend_Pdf_Destination_FitVertically($resource); break; case 'FitR': return new Zend_Pdf_Destination_FitRectangle($resource); break; case 'FitB': return new Zend_Pdf_Destination_FitBoundingBox($resource); break; case 'FitBH': return new Zend_Pdf_Destination_FitBoundingBoxHorizontally($resource); break; case 'FitBV': return new Zend_Pdf_Destination_FitBoundingBoxVertically($resource); break; default: return new Zend_Pdf_Destination_Unknown($resource); break; } } }

/* @source /library/Zend/Pdf/Canvas/Abstract.php */
abstract class Zend_Pdf_Canvas_Abstract implements Zend_Pdf_Canvas_Interface { protected $_contents = ''; protected $_font = null; protected $_fontSize; protected $_style = null; protected $_saveCount = 0; abstract protected function _addProcSet($procSetName); abstract protected function _attachResource($type, Zend_Pdf_Resource $resource); public function drawCanvas(Zend_Pdf_Canvas_Interface $canvas, $x1, $y1, $x2 = null, $y2 = null) { $this->saveGS(); $this->translate($x1, $y1); if ($x2 === null) { $with = $canvas->getWidth(); } else { $with = $x2 - $x1; } if ($y2 === null) { $height = $canvas->getHeight(); } else { $height = $y2 - $y1; } $this->clipRectangle(0, 0, $with, $height); if ($x2 !== null || $y2 !== null) { if ($x2 !== null) { $xScale = $with/$canvas->getWidth(); } else { $xScale = 1; } if ($y2 !== null) { $yScale = $height/$canvas->getHeight(); } else { $yScale = 1; } $this->scale($xScale, $yScale); } $contentsToDraw = $canvas->getContents(); $this->restoreGS(); return $this; } public function setFillColor(Zend_Pdf_Color $color) { $this->_addProcSet('PDF'); $this->_contents .= $color->instructions(false); return $this; } public function setLineColor(Zend_Pdf_Color $color) { $this->_addProcSet('PDF'); $this->_contents .= $color->instructions(true); return $this; } public function setLineWidth($width) { $this->_addProcSet('PDF'); $widthObj = new Zend_Pdf_Element_Numeric($width); $this->_contents .= $widthObj->toString() . " w\n"; return $this; } public function setLineDashingPattern($pattern, $phase = 0) { $this->_addProcSet('PDF'); if ($pattern === Zend_Pdf_Page::LINE_DASHING_SOLID) { $pattern = array(); $phase = 0; } $dashPattern = new Zend_Pdf_Element_Array(); $phaseEleemnt = new Zend_Pdf_Element_Numeric($phase); foreach ($pattern as $dashItem) { $dashElement = new Zend_Pdf_Element_Numeric($dashItem); $dashPattern->items[] = $dashElement; } $this->_contents .= $dashPattern->toString() . ' ' . $phaseEleemnt->toString() . " d\n"; return $this; } public function setFont(Zend_Pdf_Resource_Font $font, $fontSize) { $this->_addProcSet('Text'); $fontName = $this->_attachResource('Font', $font); $this->_font = $font; $this->_fontSize = $fontSize; $fontNameObj = new Zend_Pdf_Element_Name($fontName); $fontSizeObj = new Zend_Pdf_Element_Numeric($fontSize); $this->_contents .= $fontNameObj->toString() . ' ' . $fontSizeObj->toString() . " Tf\n"; return $this; } public function setStyle(Zend_Pdf_Style $style) { $this->_addProcSet('Text'); $this->_addProcSet('PDF'); if ($style->getFont() !== null) { $this->setFont($style->getFont(), $style->getFontSize()); } $this->_contents .= $style->instructions($this->_dictionary->Resources); $this->_style = $style; return $this; } public function getFont() { return $this->_font; } public function getFontSize() { return $this->_fontSize; } public function getStyle() { return $this->_style; } public function saveGS() { $this->_saveCount++; $this->_addProcSet('PDF'); $this->_contents .= " q\n"; return $this; } public function restoreGS() { if ($this->_saveCount-- <= 0) { throw new Zend_Pdf_Exception('Restoring graphics state which is not saved'); } $this->_contents .= " Q\n"; return $this; } public function setAlpha($alpha, $mode = 'Normal') { $this->_addProcSet('Text'); $this->_addProcSet('PDF'); $graphicsState = new Zend_Pdf_Resource_GraphicsState(); $graphicsState->setAlpha($alpha, $mode); $gStateName = $this->_attachResource('ExtGState', $graphicsState); $gStateNameObject = new Zend_Pdf_Element_Name($gStateName); $this->_contents .= $gStateNameObject->toString() . " gs\n"; return $this; } public function clipCircle($x, $y, $radius, $startAngle = null, $endAngle = null) { $this->clipEllipse($x - $radius, $y - $radius, $x + $radius, $y + $radius, $startAngle, $endAngle); return $this; } public function clipEllipse($x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null) { $this->_addProcSet('PDF'); if ($x2 < $x1) { $temp = $x1; $x1 = $x2; $x2 = $temp; } if ($y2 < $y1) { $temp = $y1; $y1 = $y2; $y2 = $temp; } $x = ($x1 + $x2)/2.; $y = ($y1 + $y2)/2.; $xC = new Zend_Pdf_Element_Numeric($x); $yC = new Zend_Pdf_Element_Numeric($y); if ($startAngle !== null) { if ($startAngle != 0) { $startAngle = fmod($startAngle, M_PI*2); } if ($endAngle != 0) { $endAngle = fmod($endAngle, M_PI*2); } if ($startAngle > $endAngle) { $endAngle += M_PI*2; } $clipPath = $xC->toString() . ' ' . $yC->toString() . " m\n"; $clipSectors = (int)ceil(($endAngle - $startAngle)/M_PI_4); $clipRadius = max($x2 - $x1, $y2 - $y1); for($count = 0; $count <= $clipSectors; $count++) { $pAngle = $startAngle + ($endAngle - $startAngle)*$count/(float)$clipSectors; $pX = new Zend_Pdf_Element_Numeric($x + cos($pAngle)*$clipRadius); $pY = new Zend_Pdf_Element_Numeric($y + sin($pAngle)*$clipRadius); $clipPath .= $pX->toString() . ' ' . $pY->toString() . " l\n"; } $this->_contents .= $clipPath . "h\nW\nn\n"; } $xLeft = new Zend_Pdf_Element_Numeric($x1); $xRight = new Zend_Pdf_Element_Numeric($x2); $yUp = new Zend_Pdf_Element_Numeric($y2); $yDown = new Zend_Pdf_Element_Numeric($y1); $xDelta = 2*(M_SQRT2 - 1)*($x2 - $x1)/3.; $yDelta = 2*(M_SQRT2 - 1)*($y2 - $y1)/3.; $xr = new Zend_Pdf_Element_Numeric($x + $xDelta); $xl = new Zend_Pdf_Element_Numeric($x - $xDelta); $yu = new Zend_Pdf_Element_Numeric($y + $yDelta); $yd = new Zend_Pdf_Element_Numeric($y - $yDelta); $this->_contents .= $xC->toString() . ' ' . $yUp->toString() . " m\n" . $xr->toString() . ' ' . $yUp->toString() . ' ' . $xRight->toString() . ' ' . $yu->toString() . ' ' . $xRight->toString() . ' ' . $yC->toString() . " c\n" . $xRight->toString() . ' ' . $yd->toString() . ' ' . $xr->toString() . ' ' . $yDown->toString() . ' ' . $xC->toString() . ' ' . $yDown->toString() . " c\n" . $xl->toString() . ' ' . $yDown->toString() . ' ' . $xLeft->toString() . ' ' . $yd->toString() . ' ' . $xLeft->toString() . ' ' . $yC->toString() . " c\n" . $xLeft->toString() . ' ' . $yu->toString() . ' ' . $xl->toString() . ' ' . $yUp->toString() . ' ' . $xC->toString() . ' ' . $yUp->toString() . " c\n" . "h\nW\nn\n"; return $this; } public function clipPolygon($x, $y, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING) { $this->_addProcSet('PDF'); $firstPoint = true; foreach ($x as $id => $xVal) { $xObj = new Zend_Pdf_Element_Numeric($xVal); $yObj = new Zend_Pdf_Element_Numeric($y[$id]); if ($firstPoint) { $path = $xObj->toString() . ' ' . $yObj->toString() . " m\n"; $firstPoint = false; } else { $path .= $xObj->toString() . ' ' . $yObj->toString() . " l\n"; } } $this->_contents .= $path; if ($fillMethod == Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING) { $this->_contents .= " h\n W\nn\n"; } else { $this->_contents .= " h\n W*\nn\n"; } return $this; } public function clipRectangle($x1, $y1, $x2, $y2) { $this->_addProcSet('PDF'); $x1Obj = new Zend_Pdf_Element_Numeric($x1); $y1Obj = new Zend_Pdf_Element_Numeric($y1); $widthObj = new Zend_Pdf_Element_Numeric($x2 - $x1); $height2Obj = new Zend_Pdf_Element_Numeric($y2 - $y1); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $widthObj->toString() . ' ' . $height2Obj->toString() . " re\n" . " W\nn\n"; return $this; } public function drawCircle($x, $y, $radius, $param4 = null, $param5 = null, $param6 = null) { $this->drawEllipse($x - $radius, $y - $radius, $x + $radius, $y + $radius, $param4, $param5, $param6); return $this; } public function drawEllipse($x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null) { if ($param5 === null) { $startAngle = null; $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE; } else if ($param6 === null) { $startAngle = null; $fillType = $param5; } else { $startAngle = $param5; $endAngle = $param6; if ($param7 === null) { $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE; } else { $fillType = $param7; } } $this->_addProcSet('PDF'); if ($x2 < $x1) { $temp = $x1; $x1 = $x2; $x2 = $temp; } if ($y2 < $y1) { $temp = $y1; $y1 = $y2; $y2 = $temp; } $x = ($x1 + $x2)/2.; $y = ($y1 + $y2)/2.; $xC = new Zend_Pdf_Element_Numeric($x); $yC = new Zend_Pdf_Element_Numeric($y); if ($startAngle !== null) { if ($startAngle != 0) { $startAngle = fmod($startAngle, M_PI*2); } if ($endAngle != 0) { $endAngle = fmod($endAngle, M_PI*2); } if ($startAngle > $endAngle) { $endAngle += M_PI*2; } $clipPath = $xC->toString() . ' ' . $yC->toString() . " m\n"; $clipSectors = (int)ceil(($endAngle - $startAngle)/M_PI_4); $clipRadius = max($x2 - $x1, $y2 - $y1); for($count = 0; $count <= $clipSectors; $count++) { $pAngle = $startAngle + ($endAngle - $startAngle)*$count/(float)$clipSectors; $pX = new Zend_Pdf_Element_Numeric($x + cos($pAngle)*$clipRadius); $pY = new Zend_Pdf_Element_Numeric($y + sin($pAngle)*$clipRadius); $clipPath .= $pX->toString() . ' ' . $pY->toString() . " l\n"; } $this->_contents .= "q\n" . $clipPath . "h\nW\nn\n"; } $xLeft = new Zend_Pdf_Element_Numeric($x1); $xRight = new Zend_Pdf_Element_Numeric($x2); $yUp = new Zend_Pdf_Element_Numeric($y2); $yDown = new Zend_Pdf_Element_Numeric($y1); $xDelta = 2*(M_SQRT2 - 1)*($x2 - $x1)/3.; $yDelta = 2*(M_SQRT2 - 1)*($y2 - $y1)/3.; $xr = new Zend_Pdf_Element_Numeric($x + $xDelta); $xl = new Zend_Pdf_Element_Numeric($x - $xDelta); $yu = new Zend_Pdf_Element_Numeric($y + $yDelta); $yd = new Zend_Pdf_Element_Numeric($y - $yDelta); $this->_contents .= $xC->toString() . ' ' . $yUp->toString() . " m\n" . $xr->toString() . ' ' . $yUp->toString() . ' ' . $xRight->toString() . ' ' . $yu->toString() . ' ' . $xRight->toString() . ' ' . $yC->toString() . " c\n" . $xRight->toString() . ' ' . $yd->toString() . ' ' . $xr->toString() . ' ' . $yDown->toString() . ' ' . $xC->toString() . ' ' . $yDown->toString() . " c\n" . $xl->toString() . ' ' . $yDown->toString() . ' ' . $xLeft->toString() . ' ' . $yd->toString() . ' ' . $xLeft->toString() . ' ' . $yC->toString() . " c\n" . $xLeft->toString() . ' ' . $yu->toString() . ' ' . $xl->toString() . ' ' . $yUp->toString() . ' ' . $xC->toString() . ' ' . $yUp->toString() . " c\n"; switch ($fillType) { case Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE: $this->_contents .= " B*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_FILL: $this->_contents .= " f*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_STROKE: $this->_contents .= " S\n"; break; } if ($startAngle !== null) { $this->_contents .= "Q\n"; } return $this; } public function drawImage(Zend_Pdf_Resource_Image $image, $x1, $y1, $x2, $y2) { $this->_addProcSet('PDF'); $imageName = $this->_attachResource('XObject', $image); $imageNameObj = new Zend_Pdf_Element_Name($imageName); $x1Obj = new Zend_Pdf_Element_Numeric($x1); $y1Obj = new Zend_Pdf_Element_Numeric($y1); $widthObj = new Zend_Pdf_Element_Numeric($x2 - $x1); $heightObj = new Zend_Pdf_Element_Numeric($y2 - $y1); $this->_contents .= "q\n" . '1 0 0 1 ' . $x1Obj->toString() . ' ' . $y1Obj->toString() . " cm\n" . $widthObj->toString() . ' 0 0 ' . $heightObj->toString() . " 0 0 cm\n" . $imageNameObj->toString() . " Do\n" . "Q\n"; return $this; } public function drawLayoutBox($box, $x, $y) { return $this; } public function drawLine($x1, $y1, $x2, $y2) { $this->_addProcSet('PDF'); $x1Obj = new Zend_Pdf_Element_Numeric($x1); $y1Obj = new Zend_Pdf_Element_Numeric($y1); $x2Obj = new Zend_Pdf_Element_Numeric($x2); $y2Obj = new Zend_Pdf_Element_Numeric($y2); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " m\n" . $x2Obj->toString() . ' ' . $y2Obj->toString() . " l\n S\n"; return $this; } public function drawPolygon($x, $y, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING) { $this->_addProcSet('PDF'); $firstPoint = true; foreach ($x as $id => $xVal) { $xObj = new Zend_Pdf_Element_Numeric($xVal); $yObj = new Zend_Pdf_Element_Numeric($y[$id]); if ($firstPoint) { $path = $xObj->toString() . ' ' . $yObj->toString() . " m\n"; $firstPoint = false; } else { $path .= $xObj->toString() . ' ' . $yObj->toString() . " l\n"; } } $this->_contents .= $path; switch ($fillType) { case Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE: if ($fillMethod == Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING) { $this->_contents .= " b\n"; } else { $this->_contents .= " b*\n"; } break; case Zend_Pdf_Page::SHAPE_DRAW_FILL: if ($fillMethod == Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING) { $this->_contents .= " h\n f\n"; } else { $this->_contents .= " h\n f*\n"; } break; case Zend_Pdf_Page::SHAPE_DRAW_STROKE: $this->_contents .= " S\n"; break; } return $this; } public function drawRectangle($x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE) { $this->_addProcSet('PDF'); $x1Obj = new Zend_Pdf_Element_Numeric($x1); $y1Obj = new Zend_Pdf_Element_Numeric($y1); $widthObj = new Zend_Pdf_Element_Numeric($x2 - $x1); $height2Obj = new Zend_Pdf_Element_Numeric($y2 - $y1); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $widthObj->toString() . ' ' . $height2Obj->toString() . " re\n"; switch ($fillType) { case Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE: $this->_contents .= " B*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_FILL: $this->_contents .= " f*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_STROKE: $this->_contents .= " S\n"; break; } return $this; } public function drawRoundedRectangle($x1, $y1, $x2, $y2, $radius, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE) { $this->_addProcSet('PDF'); if(!is_array($radius)) { $radius = array($radius, $radius, $radius, $radius); } else { for ($i = 0; $i < 4; $i++) { if(!isset($radius[$i])) { $radius[$i] = 0; } } } $topLeftX = $x1; $topLeftY = $y2; $topRightX = $x2; $topRightY = $y2; $bottomRightX = $x2; $bottomRightY = $y1; $bottomLeftX = $x1; $bottomLeftY = $y1; $x1Obj = new Zend_Pdf_Element_Numeric($topLeftX + $radius[0]); $y1Obj = new Zend_Pdf_Element_Numeric($topLeftY); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " m\n"; $x1Obj = new Zend_Pdf_Element_Numeric($topRightX - $radius[1]); $y1Obj = new Zend_Pdf_Element_Numeric($topRightY); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " l\n"; if ($radius[1] != 0) { $x1Obj = new Zend_Pdf_Element_Numeric($topRightX); $y1Obj = new Zend_Pdf_Element_Numeric($topRightY); $x2Obj = new Zend_Pdf_Element_Numeric($topRightX); $y2Obj = new Zend_Pdf_Element_Numeric($topRightY); $x3Obj = new Zend_Pdf_Element_Numeric($topRightX); $y3Obj = new Zend_Pdf_Element_Numeric($topRightY - $radius[1]); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $x2Obj->toString() . ' ' . $y2Obj->toString() . ' ' . $x3Obj->toString() . ' ' . $y3Obj->toString() . ' ' . " c\n"; } $x1Obj = new Zend_Pdf_Element_Numeric($bottomRightX); $y1Obj = new Zend_Pdf_Element_Numeric($bottomRightY + $radius[2]); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " l\n"; if ($radius[2] != 0) { $x1Obj = new Zend_Pdf_Element_Numeric($bottomRightX); $y1Obj = new Zend_Pdf_Element_Numeric($bottomRightY); $x2Obj = new Zend_Pdf_Element_Numeric($bottomRightX); $y2Obj = new Zend_Pdf_Element_Numeric($bottomRightY); $x3Obj = new Zend_Pdf_Element_Numeric($bottomRightX - $radius[2]); $y3Obj = new Zend_Pdf_Element_Numeric($bottomRightY); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $x2Obj->toString() . ' ' . $y2Obj->toString() . ' ' . $x3Obj->toString() . ' ' . $y3Obj->toString() . ' ' . " c\n"; } $x1Obj = new Zend_Pdf_Element_Numeric($bottomLeftX + $radius[3]); $y1Obj = new Zend_Pdf_Element_Numeric($bottomLeftY); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " l\n"; if ($radius[3] != 0) { $x1Obj = new Zend_Pdf_Element_Numeric($bottomLeftX); $y1Obj = new Zend_Pdf_Element_Numeric($bottomLeftY); $x2Obj = new Zend_Pdf_Element_Numeric($bottomLeftX); $y2Obj = new Zend_Pdf_Element_Numeric($bottomLeftY); $x3Obj = new Zend_Pdf_Element_Numeric($bottomLeftX); $y3Obj = new Zend_Pdf_Element_Numeric($bottomLeftY + $radius[3]); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $x2Obj->toString() . ' ' . $y2Obj->toString() . ' ' . $x3Obj->toString() . ' ' . $y3Obj->toString() . ' ' . " c\n"; } $x1Obj = new Zend_Pdf_Element_Numeric($topLeftX); $y1Obj = new Zend_Pdf_Element_Numeric($topLeftY - $radius[0]); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . " l\n"; if ($radius[0] != 0) { $x1Obj = new Zend_Pdf_Element_Numeric($topLeftX); $y1Obj = new Zend_Pdf_Element_Numeric($topLeftY); $x2Obj = new Zend_Pdf_Element_Numeric($topLeftX); $y2Obj = new Zend_Pdf_Element_Numeric($topLeftY); $x3Obj = new Zend_Pdf_Element_Numeric($topLeftX + $radius[0]); $y3Obj = new Zend_Pdf_Element_Numeric($topLeftY); $this->_contents .= $x1Obj->toString() . ' ' . $y1Obj->toString() . ' ' . $x2Obj->toString() . ' ' . $y2Obj->toString() . ' ' . $x3Obj->toString() . ' ' . $y3Obj->toString() . ' ' . " c\n"; } switch ($fillType) { case Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE: $this->_contents .= " B*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_FILL: $this->_contents .= " f*\n"; break; case Zend_Pdf_Page::SHAPE_DRAW_STROKE: $this->_contents .= " S\n"; break; } return $this; } public function drawText($text, $x, $y, $charEncoding = '') { if ($this->_font === null) { throw new Zend_Pdf_Exception('Font has not been set'); } $this->_addProcSet('Text'); $textObj = new Zend_Pdf_Element_String($this->_font->encodeString($text, $charEncoding)); $xObj = new Zend_Pdf_Element_Numeric($x); $yObj = new Zend_Pdf_Element_Numeric($y); $this->_contents .= "BT\n" . $xObj->toString() . ' ' . $yObj->toString() . " Td\n" . $textObj->toString() . " Tj\n" . "ET\n"; return $this; } public function pathClose() { return $this; } public function pathLine($x, $y) { return $this; } public function pathMove($x, $y) { return $this; } public function rotate($x, $y, $angle) { $cos = new Zend_Pdf_Element_Numeric(cos($angle)); $sin = new Zend_Pdf_Element_Numeric(sin($angle)); $mSin = new Zend_Pdf_Element_Numeric(-$sin->value); $xObj = new Zend_Pdf_Element_Numeric($x); $yObj = new Zend_Pdf_Element_Numeric($y); $mXObj = new Zend_Pdf_Element_Numeric(-$x); $mYObj = new Zend_Pdf_Element_Numeric(-$y); $this->_addProcSet('PDF'); $this->_contents .= '1 0 0 1 ' . $xObj->toString() . ' ' . $yObj->toString() . " cm\n" . $cos->toString() . ' ' . $sin->toString() . ' ' . $mSin->toString() . ' ' . $cos->toString() . " 0 0 cm\n" . '1 0 0 1 ' . $mXObj->toString() . ' ' . $mYObj->toString() . " cm\n"; return $this; } public function scale($xScale, $yScale) { $xScaleObj = new Zend_Pdf_Element_Numeric($xScale); $yScaleObj = new Zend_Pdf_Element_Numeric($yScale); $this->_addProcSet('PDF'); $this->_contents .= $xScaleObj->toString() . ' 0 0 ' . $yScaleObj->toString() . " 0 0 cm\n"; return $this; } public function translate($xShift, $yShift) { $xShiftObj = new Zend_Pdf_Element_Numeric($xShift); $yShiftObj = new Zend_Pdf_Element_Numeric($yShift); $this->_addProcSet('PDF'); $this->_contents .= '1 0 0 1 ' . $xShiftObj->toString() . ' ' . $yShiftObj->toString() . " cm\n"; return $this; } public function skew($x, $y, $xAngle, $yAngle) { $tanXObj = new Zend_Pdf_Element_Numeric(tan($xAngle)); $tanYObj = new Zend_Pdf_Element_Numeric(-tan($yAngle)); $xObj = new Zend_Pdf_Element_Numeric($x); $yObj = new Zend_Pdf_Element_Numeric($y); $mXObj = new Zend_Pdf_Element_Numeric(-$x); $mYObj = new Zend_Pdf_Element_Numeric(-$y); $this->_addProcSet('PDF'); $this->_contents .= '1 0 0 1 ' . $xObj->toString() . ' ' . $yObj->toString() . " cm\n" . '1 ' . $tanXObj->toString() . ' ' . $tanYObj->toString() . " 1 0 0 cm\n" . '1 0 0 1 ' . $mXObj->toString() . ' ' . $mYObj->toString() . " cm\n"; return $this; } public function rawWrite($data, $procSet = null) { if (! empty($procSet)) { $this->_addProcSet($procSet); } $this->_contents .= $data; return $this; } }

/* @source /library/Zend/Pdf/Resource/Image.php */
abstract class Zend_Pdf_Resource_Image extends Zend_Pdf_Resource { public function __construct() { parent::__construct(''); $this->_resource->dictionary->Type = new Zend_Pdf_Element_Name('XObject'); $this->_resource->dictionary->Subtype = new Zend_Pdf_Element_Name('Image'); } abstract public function getPixelHeight(); abstract public function getPixelWidth(); abstract public function getProperties(); }

/* @source /library/Zend/Pdf/Resource/Font.php */
abstract class Zend_Pdf_Resource_Font extends Zend_Pdf_Resource { protected $_fontType = Zend_Pdf_Font::TYPE_UNKNOWN; protected $_fontNames = array(); protected $_isBold = false; protected $_isItalic = false; protected $_isMonospace = false; protected $_underlinePosition = 0; protected $_underlineThickness = 0; protected $_strikePosition = 0; protected $_strikeThickness = 0; protected $_unitsPerEm = 0; protected $_ascent = 0; protected $_descent = 0; protected $_lineGap = 0; public function __construct() { parent::__construct(new Zend_Pdf_Element_Dictionary()); $this->_resource->Type = new Zend_Pdf_Element_Name('Font'); } public function __toString() { return $this->getFontName(Zend_Pdf_Font::NAME_FULL, '', '//TRANSLIT'); } public function getFontType() { return $this->_fontType; } public function getFontName($nameType, $language, $characterSet = null) { if (! isset($this->_fontNames[$nameType])) { return null; } $name = null; if (is_array($language)) { foreach ($language as $code) { if (isset($this->_fontNames[$nameType][$code])) { $name = $this->_fontNames[$nameType][$code]; break; } } } else { if (isset($this->_fontNames[$nameType][$language])) { $name = $this->_fontNames[$nameType][$language]; } } if ($name === null) { $names = $this->_fontNames[$nameType]; $name = reset($names); } if (($characterSet !== null) && ($characterSet != 'UTF-16BE') && PHP_OS != 'AIX') { $name = iconv('UTF-16BE', $characterSet, $name); } return $name; } public function getFontNames() { return $this->_fontNames; } public function isBold() { return $this->_isBold; } public function isItalic() { return $this->_isItalic; } public function isMonospace() { return $this->_isMonospace; } public function getUnderlinePosition() { return $this->_underlinePosition; } public function getUnderlineThickness() { return $this->_underlineThickness; } public function getStrikePosition() { return $this->_strikePosition; } public function getStrikeThickness() { return $this->_strikeThickness; } public function getUnitsPerEm() { return $this->_unitsPerEm; } public function getAscent() { return $this->_ascent; } public function getDescent() { return $this->_descent; } public function getLineGap() { return $this->_lineGap; } public function getLineHeight() { return $this->_ascent - $this->_descent + $this->_lineGap; } abstract public function glyphNumbersForCharacters($characterCodes); abstract public function glyphNumberForCharacter($characterCode); abstract public function getCoveredPercentage($string, $charEncoding = ''); abstract public function widthsForGlyphs($glyphNumbers); abstract public function widthForGlyph($glyphNumber); abstract public function encodeString($string, $charEncoding); abstract public function decodeString($string, $charEncoding); public function toEmSpace($value) { if ($this->_unitsPerEm == 1000) { return $value; } return ceil(($value / $this->_unitsPerEm) * 1000); } }

/* @source /library/Zend/Pdf/FileParser/Font.php */
abstract class Zend_Pdf_FileParser_Font extends Zend_Pdf_FileParser { private $_fontProperties = array(); private $_debug = false; public function __construct(Zend_Pdf_FileParserDataSource $dataSource) { parent::__construct($dataSource); $this->fontType = Zend_Pdf_Font::TYPE_UNKNOWN; } public function __get($property) { if (isset($this->_fontProperties[$property])) { return $this->_fontProperties[$property]; } else { return null; } } public function readStringUTF16($byteCount, $byteOrder = Zend_Pdf_FileParser::BYTE_ORDER_BIG_ENDIAN, $characterSet = '') { return parent::readStringUTF16($byteCount, $byteOrder, 'UTF-16BE'); } public function readStringMacRoman($byteCount, $characterSet = '') { return parent::readStringMacRoman($byteCount, 'UTF-16BE'); } public function readStringPascal($characterSet = '', $lengthBytes = 1) { return parent::readStringPascal('UTF-16BE'); } public function writeDebug() { print_r($this->_fontProperties); } public function __set($property, $value) { if ($value === null) { unset($this->_fontProperties[$property]); } else { $this->_fontProperties[$property] = $value; } } protected function _debugLog($message) { if (! $this->_debug) { return; } if (func_num_args() > 1) { $args = func_get_args(); $message = array_shift($args); $message = vsprintf($message, $args); } $logger = new Zend_Log(); $logger->log($message, Zend_Log::DEBUG); } }

/* @source /library/Zend/Pdf/Destination/Explicit.php */
abstract class Zend_Pdf_Destination_Explicit extends Zend_Pdf_Destination { protected $_destinationArray; protected $_isRemote; public function __construct(Zend_Pdf_Element $destinationArray) { if ($destinationArray->getType() != Zend_Pdf_Element::TYPE_ARRAY) { throw new Zend_Pdf_Exception('Explicit destination resource Array must be a direct or an indirect array object.'); } $this->_destinationArray = $destinationArray; switch (count($this->_destinationArray->items)) { case 0: throw new Zend_Pdf_Exception('Destination array must contain a page reference.'); break; case 1: throw new Zend_Pdf_Exception('Destination array must contain a destination type name.'); break; default: break; } switch ($this->_destinationArray->items[0]->getType()) { case Zend_Pdf_Element::TYPE_NUMERIC: $this->_isRemote = true; break; case Zend_Pdf_Element::TYPE_DICTIONARY: $this->_isRemote = false; break; default: throw new Zend_Pdf_Exception('Destination target must be a page number or page dictionary object.'); break; } } public function isRemote() { return $this->_isRemote; } public function getResource() { return $this->_destinationArray; } }

/* @source /library/Zend/Pdf/FileParser/Image.php */
abstract class Zend_Pdf_FileParser_Image extends Zend_Pdf_FileParser { protected $imageType; public function __construct(Zend_Pdf_FileParserDataSource $dataSource) { parent::__construct($dataSource); $this->imageType = Zend_Pdf_Image::TYPE_UNKNOWN; } }

/* @source /library/Zend/Pdf/Filter/Compression.php */
abstract class Zend_Pdf_Filter_Compression implements Zend_Pdf_Filter_Interface { private static function _paeth($a, $b, $c) { $p = $a + $b - $c; $pa = abs($p - $a); $pb = abs($p - $b); $pc = abs($p - $c); if ($pa <= $pb && $pa <= $pc) { return $a; } else if ($pb <= $pc) { return $b; } else { return $c; } } private static function _getPredictorValue(&$params) { if (isset($params['Predictor'])) { $predictor = $params['Predictor']; if ($predictor != 1 && $predictor != 2 && $predictor != 10 && $predictor != 11 && $predictor != 12 && $predictor != 13 && $predictor != 14 && $predictor != 15) { throw new Zend_Pdf_Exception('Invalid value of \'Predictor\' decode param - ' . $predictor . '.' ); } return $predictor; } else { return 1; } } private static function _getColorsValue(&$params) { if (isset($params['Colors'])) { $colors = $params['Colors']; if ($colors != 1 && $colors != 2 && $colors != 3 && $colors != 4) { throw new Zend_Pdf_Exception('Invalid value of \'Color\' decode param - ' . $colors . '.' ); } return $colors; } else { return 1; } } private static function _getBitsPerComponentValue(&$params) { if (isset($params['BitsPerComponent'])) { $bitsPerComponent = $params['BitsPerComponent']; if ($bitsPerComponent != 1 && $bitsPerComponent != 2 && $bitsPerComponent != 4 && $bitsPerComponent != 8 && $bitsPerComponent != 16 ) { throw new Zend_Pdf_Exception('Invalid value of \'BitsPerComponent\' decode param - ' . $bitsPerComponent . '.' ); } return $bitsPerComponent; } else { return 8; } } private static function _getColumnsValue(&$params) { if (isset($params['Columns'])) { return $params['Columns']; } else { return 1; } } protected static function _applyEncodeParams($data, $params) { $predictor = self::_getPredictorValue($params); $colors = self::_getColorsValue($params); $bitsPerComponent = self::_getBitsPerComponentValue($params); $columns = self::_getColumnsValue($params); if ($predictor == 1) { return $data; } if ($predictor == 2) { throw new Zend_Pdf_Exception('Not implemented yet' ); } if ($predictor == 15) { $predictor = 14; } if ($predictor == 10 || $predictor == 11 || $predictor == 12 || $predictor == 13 || $predictor == 14 ) { $predictor -= 10; if($bitsPerComponent == 16) { throw new Zend_Pdf_Exception("PNG Prediction with bit depth greater than 8 not yet supported."); } $bitsPerSample = $bitsPerComponent*$colors; $bytesPerSample = (int)(($bitsPerSample + 7)/8); $bytesPerRow = (int)(($bitsPerSample*$columns + 7)/8); $rows = strlen($data)/$bytesPerRow; $output = ''; $offset = 0; if (!is_integer($rows)) { throw new Zend_Pdf_Exception('Wrong data length.'); } switch ($predictor) { case 0: for ($count = 0; $count < $rows; $count++) { $output .= chr($predictor); $output .= substr($data, $offset, $bytesPerRow); $offset += $bytesPerRow; } break; case 1: for ($count = 0; $count < $rows; $count++) { $output .= chr($predictor); $lastSample = array_fill(0, $bytesPerSample, 0); for ($count2 = 0; $count2 < $bytesPerRow; $count2++) { $newByte = ord($data[$offset++]); $output .= chr($newByte - $lastSample[$count2 % $bytesPerSample]); $lastSample[$count2 % $bytesPerSample] = $newByte; } } break; case 2: $lastRow = array_fill(0, $bytesPerRow, 0); for ($count = 0; $count < $rows; $count++) { $output .= chr($predictor); for ($count2 = 0; $count2 < $bytesPerRow; $count2++) { $newByte = ord($data[$offset++]); $output .= chr($newByte - $lastRow[$count2]); $lastRow[$count2] = $newByte; } } break; case 3: $lastRow = array_fill(0, $bytesPerRow, 0); for ($count = 0; $count < $rows; $count++) { $output .= chr($predictor); $lastSample = array_fill(0, $bytesPerSample, 0); for ($count2 = 0; $count2 < $bytesPerRow; $count2++) { $newByte = ord($data[$offset++]); $output .= chr($newByte - floor(( $lastSample[$count2 % $bytesPerSample] + $lastRow[$count2])/2)); $lastSample[$count2 % $bytesPerSample] = $lastRow[$count2] = $newByte; } } break; case 4: $lastRow = array_fill(0, $bytesPerRow, 0); $currentRow = array(); for ($count = 0; $count < $rows; $count++) { $output .= chr($predictor); $lastSample = array_fill(0, $bytesPerSample, 0); for ($count2 = 0; $count2 < $bytesPerRow; $count2++) { $newByte = ord($data[$offset++]); $output .= chr($newByte - self::_paeth( $lastSample[$count2 % $bytesPerSample], $lastRow[$count2], ($count2 - $bytesPerSample < 0)? 0 : $lastRow[$count2 - $bytesPerSample] )); $lastSample[$count2 % $bytesPerSample] = $currentRow[$count2] = $newByte; } $lastRow = $currentRow; } break; } return $output; } throw new Zend_Pdf_Exception('Unknown prediction algorithm - ' . $predictor . '.' ); } protected static function _applyDecodeParams($data, $params) { $predictor = self::_getPredictorValue($params); $colors = self::_getColorsValue($params); $bitsPerComponent = self::_getBitsPerComponentValue($params); $columns = self::_getColumnsValue($params); if ($predictor == 1) { return $data; } if ($predictor == 2) { throw new Zend_Pdf_Exception('Not implemented yet' ); } if ($predictor == 10 || $predictor == 11 || $predictor == 12 || $predictor == 13 || $predictor == 14 || $predictor == 15 ) { $bitsPerSample = $bitsPerComponent*$colors; $bytesPerSample = ceil($bitsPerSample/8); $bytesPerRow = ceil($bitsPerSample*$columns/8); $rows = ceil(strlen($data)/($bytesPerRow + 1)); $output = ''; $offset = 0; $lastRow = array_fill(0, $bytesPerRow, 0); for ($count = 0; $count < $rows; $count++) { $lastSample = array_fill(0, $bytesPerSample, 0); switch (ord($data[$offset++])) { case 0: $output .= substr($data, $offset, $bytesPerRow); for ($count2 = 0; $count2 < $bytesPerRow && $offset < strlen($data); $count2++) { $lastSample[$count2 % $bytesPerSample] = $lastRow[$count2] = ord($data[$offset++]); } break; case 1: for ($count2 = 0; $count2 < $bytesPerRow && $offset < strlen($data); $count2++) { $decodedByte = (ord($data[$offset++]) + $lastSample[$count2 % $bytesPerSample]) & 0xFF; $lastSample[$count2 % $bytesPerSample] = $lastRow[$count2] = $decodedByte; $output .= chr($decodedByte); } break; case 2: for ($count2 = 0; $count2 < $bytesPerRow && $offset < strlen($data); $count2++) { $decodedByte = (ord($data[$offset++]) + $lastRow[$count2]) & 0xFF; $lastSample[$count2 % $bytesPerSample] = $lastRow[$count2] = $decodedByte; $output .= chr($decodedByte); } break; case 3: for ($count2 = 0; $count2 < $bytesPerRow && $offset < strlen($data); $count2++) { $decodedByte = (ord($data[$offset++]) + floor(( $lastSample[$count2 % $bytesPerSample] + $lastRow[$count2])/2) ) & 0xFF; $lastSample[$count2 % $bytesPerSample] = $lastRow[$count2] = $decodedByte; $output .= chr($decodedByte); } break; case 4: $currentRow = array(); for ($count2 = 0; $count2 < $bytesPerRow && $offset < strlen($data); $count2++) { $decodedByte = (ord($data[$offset++]) + self::_paeth($lastSample[$count2 % $bytesPerSample], $lastRow[$count2], ($count2 - $bytesPerSample < 0)? 0 : $lastRow[$count2 - $bytesPerSample]) ) & 0xFF; $lastSample[$count2 % $bytesPerSample] = $currentRow[$count2] = $decodedByte; $output .= chr($decodedByte); } $lastRow = $currentRow; break; default: throw new Zend_Pdf_Exception('Unknown prediction tag.'); } } return $output; } throw new Zend_Pdf_Exception('Unknown prediction algorithm - ' . $predictor . '.' ); } }

/* @source /library/Zend/Pdf/Resource/Font/CidFont.php */
abstract class Zend_Pdf_Resource_Font_CidFont extends Zend_Pdf_Resource_Font { protected $_cmap = null; protected $_charWidths = null; protected $_missingCharWidth = 0; public function __construct(Zend_Pdf_FileParser_Font_OpenType $fontParser) { parent::__construct(); $fontParser->parse(); $this->_fontNames = $fontParser->names; $this->_isBold = $fontParser->isBold; $this->_isItalic = $fontParser->isItalic; $this->_isMonospaced = $fontParser->isMonospaced; $this->_underlinePosition = $fontParser->underlinePosition; $this->_underlineThickness = $fontParser->underlineThickness; $this->_strikePosition = $fontParser->strikePosition; $this->_strikeThickness = $fontParser->strikeThickness; $this->_unitsPerEm = $fontParser->unitsPerEm; $this->_ascent = $fontParser->ascent; $this->_descent = $fontParser->descent; $this->_lineGap = $fontParser->lineGap; $this->_cmap = $fontParser->cmap; $baseFont = $this->getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, 'en', 'UTF-8'); $this->_resource->BaseFont = new Zend_Pdf_Element_Name($baseFont); $glyphWidths = $fontParser->glyphWidths; $charGlyphs = $this->_cmap->getCoveredCharactersGlyphs(); $charWidths = array(); foreach ($charGlyphs as $charCode => $glyph) { if(isset($glyphWidths[$glyph]) && !is_null($glyphWidths[$glyph])) { $charWidths[$charCode] = $glyphWidths[$glyph]; } } $this->_charWidths = $charWidths; $this->_missingCharWidth = $glyphWidths[0]; $widthFrequencies = array_count_values($charWidths); $defaultWidth = null; $defaultWidthFrequency = -1; foreach ($widthFrequencies as $width => $frequency) { if ($frequency > $defaultWidthFrequency) { $defaultWidth = $width; $defaultWidthFrequency = $frequency; } } $this->_resource->DW = new Zend_Pdf_Element_Numeric($this->toEmSpace($defaultWidth)); $defWidthChars = array_keys($charWidths, $defaultWidth); foreach ($defWidthChars as $charCode) { unset($charWidths[$charCode]); } ksort($charWidths, SORT_NUMERIC); $lastCharCode = -1; $widthsSequences = array(); foreach ($charWidths as $charCode => $width) { if ($lastCharCode == -1) { $charCodesSequense = array(); $sequenceStartCode = $charCode; } else if ($charCode != $lastCharCode + 1) { $widthsSequences[$sequenceStartCode] = $charCodesSequense; $charCodesSequense = array(); $sequenceStartCode = $charCode; } $charCodesSequense[] = $width; $lastCharCode = $charCode; } if (count($charWidths) != 0) { $widthsSequences[$sequenceStartCode] = $charCodesSequense; } $pdfCharsWidths = array(); foreach ($widthsSequences as $startCode => $widthsSequence) { $pdfWidths = array(); $lastWidth = -1; $widthsInSequence = 0; foreach ($widthsSequence as $width) { if ($lastWidth != $width) { if ($widthsInSequence != 0) { $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode); $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode + $widthsInSequence - 1); $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($this->toEmSpace($lastWidth)); $startCode = $startCode + $widthsInSequence; $widthsInSequence = 0; } $pdfWidths[] = new Zend_Pdf_Element_Numeric($this->toEmSpace($width)); $lastWidth = $width; } else { if (count($pdfWidths) != 0) { array_pop($pdfWidths); if (count($pdfWidths) != 0) { $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode); $pdfCharsWidths[] = new Zend_Pdf_Element_Array($pdfWidths); $startCode += count($pdfWidths); $pdfWidths = array(); } $widthsInSequence = 2; } else { $widthsInSequence++; } } } if (count($pdfWidths) != 0) { $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode); $pdfCharsWidths[] = new Zend_Pdf_Element_Array($pdfWidths); } else if ($widthsInSequence != 0){ $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode); $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($startCode + $widthsInSequence - 1); $pdfCharsWidths[] = new Zend_Pdf_Element_Numeric($this->toEmSpace($lastWidth)); } } $widthsArrayElement = new Zend_Pdf_Element_Array($pdfCharsWidths); $widthsObject = $this->_objectFactory->newObject($widthsArrayElement); $this->_resource->W = $widthsObject; $cidSystemInfo = new Zend_Pdf_Element_Dictionary(); $cidSystemInfo->Registry = new Zend_Pdf_Element_String('Adobe'); $cidSystemInfo->Ordering = new Zend_Pdf_Element_String('UCS'); $cidSystemInfo->Supplement = new Zend_Pdf_Element_Numeric(0); $cidSystemInfoObject = $this->_objectFactory->newObject($cidSystemInfo); $this->_resource->CIDSystemInfo = $cidSystemInfoObject; } public function glyphNumbersForCharacters($characterCodes) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } public function glyphNumberForCharacter($characterCode) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } public function getCoveredPercentage($string, $charEncoding = '') { if ($charEncoding != 'UTF-16BE') { $string = iconv($charEncoding, 'UTF-16BE', $string); } $charCount = iconv_strlen($string, 'UTF-16BE'); if ($charCount == 0) { return 0; } $score = 0; $maxIndex = strlen($string); for ($i = 0; $i < $maxIndex; $i++) { $charCode = (ord($string[$i]) << 8) | ord($string[++$i]); if (isset($this->_charWidths[$charCode])) { $score++; } } return $score / $charCount; } public function widthsForChars($charCodes) { $widths = array(); foreach ($charCodes as $key => $charCode) { if (!isset($this->_charWidths[$charCode])) { $widths[$key] = $this->_missingCharWidth; } else { $widths[$key] = $this->_charWidths[$charCode]; } } return $widths; } public function widthForChar($charCode) { if (!isset($this->_charWidths[$charCode])) { return $this->_missingCharWidth; } return $this->_charWidths[$charCode]; } public function widthsForGlyphs($glyphNumbers) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } public function widthForGlyph($glyphNumber) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } public function encodeString($string, $charEncoding) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } public function decodeString($string, $charEncoding) { throw new Zend_Pdf_Exception('CIDFont PDF objects could not be used as the operand of the text drawing operators'); } }

/* @source /library/Zend/Pdf/FileParser/Font/OpenType.php */
abstract class Zend_Pdf_FileParser_Font_OpenType extends Zend_Pdf_FileParser_Font { protected $_scalerType = 0; protected $_tableDirectory = array(); public function screen() { if ($this->_isScreened) { return; } $this->_readScalerType(); } public function parse() { if ($this->_isParsed) { return; } $this->screen(); $this->_parseTableDirectory(); $this->_parseHeadTable(); $this->_parseNameTable(); $this->_parsePostTable(); $this->_parseHheaTable(); $this->_parseMaxpTable(); $this->_parseOs2Table(); $this->_parseHmtxTable(); $this->_parseCmapTable(); } protected function _parseTableDirectory() { $this->moveToOffset(4); $tableCount = $this->readUInt(2); $this->_debugLog('%d tables', $tableCount); if (($tableCount < 7) || ($tableCount > 50)) { throw new Zend_Pdf_Exception('Table count not within expected range', Zend_Pdf_Exception::BAD_TABLE_COUNT); } $this->skipBytes(6); for ($tableIndex = 0; $tableIndex < $tableCount; $tableIndex++) { $tableName = $this->readBytes(4); $this->skipBytes(4); $tableOffset = $this->readUInt(4); $tableLength = $this->readUInt(4); $this->_debugLog('%s offset: 0x%x; length: %d', $tableName, $tableOffset, $tableLength); $fileSize = $this->_dataSource->getSize(); if (($tableOffset < 0) || ($tableOffset > $fileSize)) { throw new Zend_Pdf_Exception("Table offset ($tableOffset) not within expected range", Zend_Pdf_Exception::INDEX_OUT_OF_RANGE); } if (($tableLength < 0) || (($tableOffset + $tableLength) > $fileSize)) { throw new Zend_Pdf_Exception("Table length ($tableLength) not within expected range", Zend_Pdf_Exception::INDEX_OUT_OF_RANGE); } $this->_tableDirectory[$tableName]['offset'] = $tableOffset; $this->_tableDirectory[$tableName]['length'] = $tableLength; } } protected function _parseHeadTable() { $this->_jumpToTable('head'); $tableVersion = $this->_readTableVersion(1, 1); $this->skipBytes(8); $magicNumber = $this->readUInt(4); if ($magicNumber != 0x5f0f3cf5) { throw new Zend_Pdf_Exception('Wrong magic number. Expected: 0x5f0f3cf5; actual: ' . sprintf('%x', $magicNumber), Zend_Pdf_Exception::BAD_MAGIC_NUMBER); } $flags = $this->readUInt(2); $this->baselineAtZero = $this->isBitSet(0, $flags); $this->useIntegerScaling = $this->isBitSet(3, $flags); $this->unitsPerEm = $this->readUInt(2); $this->_debugLog('Units per em: %d', $this->unitsPerEm); $this->skipBytes(16); $this->xMin = $this->readInt(2); $this->yMin = $this->readInt(2); $this->xMax = $this->readInt(2); $this->yMax = $this->readInt(2); $this->_debugLog('Font bounding box: %d %d %d %d', $this->xMin, $this->yMin, $this->xMax, $this->yMax); $macStyleBits = $this->readUInt(2); $this->isBold = $this->isBitSet(0, $macStyleBits); $this->isItalic = $this->isBitSet(1, $macStyleBits); } protected function _parseNameTable() { $this->_jumpToTable('name'); $baseOffset = $this->_tableDirectory['name']['offset']; $tableFormat = $this->readUInt(2); if ($tableFormat != 0) { throw new Zend_Pdf_Exception("Unable to read format $tableFormat table", Zend_Pdf_Exception::DONT_UNDERSTAND_TABLE_VERSION); } $this->_debugLog('Format %d table', $tableFormat); $nameCount = $this->readUInt(2); $this->_debugLog('%d name strings', $nameCount); $storageOffset = $this->readUInt(2) + $baseOffset; $this->_debugLog('Storage offset: 0x%x', $storageOffset); $nameRecords = array(); for ($nameIndex = 0; $nameIndex < $nameCount; $nameIndex++) { $platformID = $this->readUInt(2); $encodingID = $this->readUInt(2); if (! ( (($platformID == 3) && ($encodingID == 1)) || (($platformID == 1) && ($encodingID == 0)) ) ) { $this->skipBytes(8); continue; } $languageID = $this->readUInt(2); $nameID = $this->readUInt(2); $nameLength = $this->readUInt(2); $nameOffset = $this->readUInt(2); $languageCode = $this->_languageCodeForPlatform($platformID, $languageID); if ($languageCode === null) { $this->_debugLog('Skipping languageID: 0x%x; platformID %d', $languageID, $platformID); continue; } $this->_debugLog('Adding nameID: %d; languageID: 0x%x; platformID: %d; offset: 0x%x (0x%x); length: %d', $nameID, $languageID, $platformID, $baseOffset + $nameOffset, $nameOffset, $nameLength); $nameRecords[$nameID][$languageCode] = array('platform' => $platformID, 'offset' => $nameOffset, 'length' => $nameLength ); } $fontNames = array(); foreach ($nameRecords as $name => $languages) { foreach ($languages as $language => $attributes) { $stringOffset = $storageOffset + $attributes['offset']; $this->moveToOffset($stringOffset); if ($attributes['platform'] == 3) { $string = $this->readStringUTF16($attributes['length']); } else { $string = $this->readStringMacRoman($attributes['length']); } $fontNames[$name][$language] = $string; } } $this->names = $fontNames; } protected function _parsePostTable() { $this->_jumpToTable('post'); $tableVersion = $this->_readTableVersion(1, 4); $this->italicAngle = $this->readFixed(16, 16); $this->underlinePosition = $this->readInt(2); $this->underlineThickness = $this->readInt(2); $fixedPitch = $this->readUInt(4); $this->isMonospaced = ($fixedPitch !== 0); $this->skipBytes(16); } protected function _parseHheaTable() { $this->_jumpToTable('hhea'); $tableVersion = $this->_readTableVersion(1, 1); $this->ascent = $this->readInt(2); $this->descent = $this->readInt(2); $this->lineGap = $this->readInt(2); if ($this->descent > 0) { $this->_debugLog('Warning: Font should specify negative descent. Actual: %d; Using %d', $this->descent, -$this->descent); $this->descent = -$this->descent; } $this->skipBytes(22); $this->metricDataFormat = $this->readInt(2); $this->numberHMetrics = $this->readUInt(2); $this->_debugLog('hmtx data format: %d; number of metrics: %d', $this->metricDataFormat, $this->numberHMetrics); } protected function _parseMaxpTable() { $this->_jumpToTable('maxp'); $this->_readTableVersion(0, 1); $this->numGlyphs = $this->readUInt(2); $this->_debugLog('number of glyphs: %d', $this->numGlyphs); } protected function _parseOs2Table() { if (! $this->numberHMetrics) { throw new Zend_Pdf_Exception("hhea table must be parsed prior to calling this method", Zend_Pdf_Exception::PARSED_OUT_OF_ORDER); } try { $this->_jumpToTable('OS/2'); } catch (Zend_Pdf_Exception $e) { if ($e->getCode() == Zend_Pdf_Exception::REQUIRED_TABLE_NOT_FOUND) { $this->_debugLog('No OS/2 table found. Using default values'); $this->fontWeight = Zend_Pdf_Font::WEIGHT_NORMAL; $this->fontWidth = Zend_Pdf_Font::WIDTH_NORMAL; $this->isEmbeddable = true; $this->isSubsettable = true; $this->strikeThickness = $this->unitsPerEm * 0.05; $this->strikePosition = $this->unitsPerEm * 0.225; $this->isSerifFont = false; $this->isSansSerifFont = false; $this->isOrnamentalFont = false; $this->isScriptFont = false; $this->isSymbolicFont = false; $this->isAdobeLatinSubset = false; $this->vendorID = ''; $this->xHeight = 0; $this->capitalHeight = 0; return; } else { throw $e; throw new Zend_Pdf_Exception($e->getMessage(), $e->getCode(), $e); } } $tableVersion = $this->readUInt(2); if (($tableVersion < 0) || ($tableVersion > 3)) { throw new Zend_Pdf_Exception("Unable to read version $tableVersion table", Zend_Pdf_Exception::DONT_UNDERSTAND_TABLE_VERSION); } $this->_debugLog('Version %d table', $tableVersion); $this->averageCharWidth = $this->readInt(2); $this->fontWeight = $this->readUInt(2); $this->fontWidth = $this->readUInt(2); $embeddingFlags = $this->readUInt(2); $this->_debugLog('Embedding flags: %d', $embeddingFlags); if ($this->isBitSet(9, $embeddingFlags)) { $this->isEmbeddable = false; } elseif ($this->isBitSet(2, $embeddingFlags) || $this->isBitSet(3, $embeddingFlags) || $this->isBitSet(4, $embeddingFlags) ) { $this->isEmbeddable = true; } elseif ($this->isBitSet(1, $embeddingFlags)) { $this->isEmbeddable = false; } else { $this->isEmbeddable = true; } $this->_debugLog('Font ' . ($this->isEmbeddable ? 'may' : 'may not') . ' be embedded'); $isSubsettable = $this->isBitSet($embeddingFlags, 8); $this->subscriptXSize = $this->readInt(2); $this->subscriptYSize = $this->readInt(2); $this->subscriptXOffset = $this->readInt(2); $this->subscriptYOffset = $this->readInt(2); $this->superscriptXSize = $this->readInt(2); $this->superscriptYSize = $this->readInt(2); $this->superscriptXOffset = $this->readInt(2); $this->superscriptYOffset = $this->readInt(2); $this->strikeThickness = $this->readInt(2); $this->strikePosition = $this->readInt(2); $familyClass = ($this->readUInt(2) >> 8); $this->_debugLog('Font family class: %d', $familyClass); $this->isSerifFont = ((($familyClass >= 1) && ($familyClass <= 5)) || ($familyClass == 7)); $this->isSansSerifFont = ($familyClass == 8); $this->isOrnamentalFont = ($familyClass == 9); $this->isScriptFont = ($familyClass == 10); $this->isSymbolicFont = ($familyClass == 12); $this->skipBytes(10); $unicodeRange1 = $this->readUInt(4); $unicodeRange2 = $this->readUInt(4); $unicodeRange3 = $this->readUInt(4); $unicodeRange4 = $this->readUInt(4); $this->_debugLog('Unicode ranges: 0x%x 0x%x 0x%x 0x%x', $unicodeRange1, $unicodeRange2, $unicodeRange3, $unicodeRange4); $this->isAdobeLatinSubset = (($unicodeRange1 == 1) && ($unicodeRange2 == 0) && ($unicodeRange3 == 0) && ($unicodeRange4 == 0)); $this->_debugLog(($this->isAdobeLatinSubset ? 'Is' : 'Is not') . ' a subset of Adobe Latin'); $this->vendorID = $this->readBytes(4); $this->skipBytes(6); $this->ascent = $this->readInt(2); $this->descent = $this->readInt(2); $this->lineGap = $this->readInt(2); if ($this->descent > 0) { $this->_debugLog('Warning: Font should specify negative descent. Actual: %d; Using %d', $this->descent, -$this->descent); $this->descent = -$this->descent; } $this->skipBytes(4); if ($tableVersion < 2) { $this->xHeight = 0; $this->capitalHeight = 0; } else { $this->skipBytes(8); $this->xHeight = $this->readInt(2); $this->capitalHeight = $this->readInt(2); } } protected function _parseHmtxTable() { $this->_jumpToTable('hmtx'); if (! $this->numberHMetrics) { throw new Zend_Pdf_Exception("hhea table must be parsed prior to calling this method", Zend_Pdf_Exception::PARSED_OUT_OF_ORDER); } if ($this->metricDataFormat != 0) { throw new Zend_Pdf_Exception("Unable to read format $this->metricDataFormat table.", Zend_Pdf_Exception::DONT_UNDERSTAND_TABLE_VERSION); } $glyphWidths = array(); for ($i = 0; $i < $this->numberHMetrics; $i++) { $glyphWidths[$i] = $this->readUInt(2); $this->skipBytes(2); } while (count($glyphWidths) < $this->numGlyphs) { $glyphWidths[] = end($glyphWidths); } $this->glyphWidths = $glyphWidths; } protected function _parseCmapTable() { $this->_jumpToTable('cmap'); $baseOffset = $this->_tableDirectory['cmap']['offset']; $tableVersion = $this->readUInt(2); if ($tableVersion != 0) { throw new Zend_Pdf_Exception("Unable to read version $tableVersion table", Zend_Pdf_Exception::DONT_UNDERSTAND_TABLE_VERSION); } $this->_debugLog('Version %d table', $tableVersion); $subtableCount = $this->readUInt(2); $this->_debugLog('%d subtables', $subtableCount); $subtables = array(); for ($subtableIndex = 0; $subtableIndex < $subtableCount; $subtableIndex++) { $platformID = $this->readUInt(2); $encodingID = $this->readUInt(2); if (! ( (($platformID == 0) && ($encodingID == 3)) || (($platformID == 0) && ($encodingID == 0)) || (($platformID == 3) && ($encodingID == 1)) || (($platformID == 1) && ($encodingID == 0)) ) ) { $this->_debugLog('Unsupported encoding: platformID: %d; encodingID: %d; skipping', $platformID, $encodingID); $this->skipBytes(4); continue; } $subtableOffset = $this->readUInt(4); if ($subtableOffset < 0) { $this->_debugLog('Offset 0x%x out of range for platformID: %d; skipping', $subtableOffset, $platformID); continue; } $this->_debugLog('Found subtable; platformID: %d; encodingID: %d; offset: 0x%x (0x%x)', $platformID, $encodingID, $baseOffset + $subtableOffset, $subtableOffset); $subtables[$platformID][$encodingID][] = $subtableOffset; } $offsets = array(); if (isset($subtables[0][3])) { foreach ($subtables[0][3] as $offset) { $offsets[] = $offset; } } if (isset($subtables[0][0])) { foreach ($subtables[0][0] as $offset) { $offsets[] = $offset; } } if (isset($subtables[3][1])) { foreach ($subtables[3][1] as $offset) { $offsets[] = $offset; } } if (isset($subtables[1][0])) { foreach ($subtables[1][0] as $offset) { $offsets[] = $offset; } } $cmapType = -1; foreach ($offsets as $offset) { $cmapOffset = $baseOffset + $offset; $this->moveToOffset($cmapOffset); $format = $this->readUInt(2); $language = -1; switch ($format) { case 0x0: $cmapLength = $this->readUInt(2); $language = $this->readUInt(2); if ($language != 0) { $this->_debugLog('Type 0 cmap tables must be language-independent;' . ' language: %d; skipping', $language); continue; } break; case 0x4: case 0x6: $cmapLength = $this->readUInt(2); $language = $this->readUInt(2); if ($language != 0) { $this->_debugLog('Warning: cmap tables must be language-independent - this font' . ' may not work properly; language: %d', $language); } break; case 0x2: case 0x8: case 0xa: case 0xc: $this->_debugLog('Format: 0x%x currently unsupported; skipping', $format); continue; default: $this->_debugLog('Unknown subtable format: 0x%x; skipping', $format); continue; } $cmapType = $format; break; } if ($cmapType == -1) { throw new Zend_Pdf_Exception('Unable to find usable cmap table', Zend_Pdf_Exception::CANT_FIND_GOOD_CMAP); } $this->_debugLog('Using cmap type %d; offset: 0x%x; length: %d', $cmapType, $cmapOffset, $cmapLength); $this->moveToOffset($cmapOffset); $cmapData = $this->readBytes($cmapLength); $this->cmap = Zend_Pdf_Cmap::cmapWithTypeData($cmapType, $cmapData); } protected function _readScalerType() { if ($this->_scalerType != 0) { return $this->_scalerType; } $this->moveToOffset(0); $this->_scalerType = $this->readUInt(4); switch ($this->_scalerType) { case 0x00010000: $this->_debugLog('Windows TrueType signature'); break; case 0x74727565: $this->_debugLog('Macintosh TrueType signature'); break; case 0x4f54544f: $this->_debugLog('PostScript CFF signature'); break; case 0x74797031: throw new Zend_Pdf_Exception('Unsupported font type: PostScript in sfnt wrapper', Zend_Pdf_Exception::WRONG_FONT_TYPE); default: throw new Zend_Pdf_Exception('Not an OpenType font file', Zend_Pdf_Exception::WRONG_FONT_TYPE); } return $this->_scalerType; } protected function _jumpToTable($tableName) { if (empty($this->_tableDirectory[$tableName])) { throw new Zend_Pdf_Exception("Required table '$tableName' not found!", Zend_Pdf_Exception::REQUIRED_TABLE_NOT_FOUND); } $this->_debugLog("Parsing $tableName table..."); $this->moveToOffset($this->_tableDirectory[$tableName]['offset']); } protected function _readTableVersion($minVersion, $maxVersion) { $tableVersion = $this->readFixed(16, 16); if (($tableVersion < $minVersion) || ($tableVersion > $maxVersion)) { throw new Zend_Pdf_Exception("Unable to read version $tableVersion table", Zend_Pdf_Exception::DONT_UNDERSTAND_TABLE_VERSION); } $this->_debugLog('Version %.2f table', $tableVersion); return $tableVersion; } protected function _languageCodeForPlatform($platformID, $languageID) { if ($platformID == 3) { $languageID &= 0xff; switch ($languageID) { case 0x09: return 'en'; case 0x0c: return 'fr'; case 0x07: return 'de'; case 0x10: return 'it'; case 0x13: return 'nl'; case 0x1d: return 'sv'; case 0x0a: return 'es'; case 0x06: return 'da'; case 0x16: return 'pt'; case 0x14: return 'no'; case 0x0d: return 'he'; case 0x11: return 'ja'; case 0x01: return 'ar'; case 0x0b: return 'fi'; case 0x08: return 'el'; default: return null; } } else if ($platformID == 1) { switch ($languageID) { case 0: return 'en'; case 1: return 'fr'; case 2: return 'de'; case 3: return 'it'; case 4: return 'nl'; case 5: return 'sv'; case 6: return 'es'; case 7: return 'da'; case 8: return 'pt'; case 9: return 'no'; case 10: return 'he'; case 11: return 'ja'; case 12: return 'ar'; case 13: return 'fi'; case 14: return 'el'; default: return null; } } else { return null; } } }

/* @source /library/Zend/Pdf/Resource/Font/Simple.php */
abstract class Zend_Pdf_Resource_Font_Simple extends Zend_Pdf_Resource_Font { protected $_cmap = null; protected $_glyphWidths = null; protected $_missingGlyphWidth = 0; public function __construct() { parent::__construct(); $this->_resource->Encoding = new Zend_Pdf_Element_Name('WinAnsiEncoding'); } public function glyphNumbersForCharacters($characterCodes) { return $this->_cmap->glyphNumbersForCharacters($characterCodes); } public function glyphNumberForCharacter($characterCode) { return $this->_cmap->glyphNumberForCharacter($characterCode); } public function getCoveredPercentage($string, $charEncoding = '') { if ($charEncoding != 'UTF-16BE') { if (PHP_OS != 'AIX') { $string = iconv($charEncoding, 'UTF-16BE', $string); } } $charCount = (PHP_OS != 'AIX') ? iconv_strlen($string, 'UTF-16BE') : strlen($string); if ($charCount == 0) { return 0; } $coveredCharacters = $this->_cmap->getCoveredCharacters(); $score = 0; $maxIndex = strlen($string); for ($i = 0; $i < $maxIndex; $i++) { $charCode = (ord($string[$i]) << 8) | ord($string[++$i]); if (in_array($charCode, $coveredCharacters)) { $score++; } } return $score / $charCount; } public function widthsForGlyphs($glyphNumbers) { $widths = array(); foreach ($glyphNumbers as $key => $glyphNumber) { if (!isset($this->_glyphWidths[$glyphNumber])) { $widths[$key] = $this->_missingGlyphWidth; } else { $widths[$key] = $this->_glyphWidths[$glyphNumber]; } } return $widths; } public function widthForGlyph($glyphNumber) { if (!isset($this->_glyphWidths[$glyphNumber])) { return $this->_missingGlyphWidth; } return $this->_glyphWidths[$glyphNumber]; } public function encodeString($string, $charEncoding) { if (PHP_OS == 'AIX') { return $string; } return iconv($charEncoding, 'CP1252//IGNORE', $string); } public function decodeString($string, $charEncoding) { return iconv('CP1252', $charEncoding, $string); } }

/* @source /library/Zend/Pdf/Resource/Font/Simple/Standard.php */
abstract class Zend_Pdf_Resource_Font_Simple_Standard extends Zend_Pdf_Resource_Font_Simple { public function __construct() { $this->_fontType = Zend_Pdf_Font::TYPE_STANDARD; parent::__construct(); $this->_resource->Subtype = new Zend_Pdf_Element_Name('Type1'); } }

/* @source /library/Zend/Pdf/Resource/Font/Simple/Parsed.php */
abstract class Zend_Pdf_Resource_Font_Simple_Parsed extends Zend_Pdf_Resource_Font_Simple { public function __construct(Zend_Pdf_FileParser_Font_OpenType $fontParser) { parent::__construct(); $fontParser->parse(); $this->_fontNames = $fontParser->names; $this->_isBold = $fontParser->isBold; $this->_isItalic = $fontParser->isItalic; $this->_isMonospaced = $fontParser->isMonospaced; $this->_underlinePosition = $fontParser->underlinePosition; $this->_underlineThickness = $fontParser->underlineThickness; $this->_strikePosition = $fontParser->strikePosition; $this->_strikeThickness = $fontParser->strikeThickness; $this->_unitsPerEm = $fontParser->unitsPerEm; $this->_ascent = $fontParser->ascent; $this->_descent = $fontParser->descent; $this->_lineGap = $fontParser->lineGap; $this->_glyphWidths = $fontParser->glyphWidths; $this->_missingGlyphWidth = $this->_glyphWidths[0]; $this->_cmap = $fontParser->cmap; $baseFont = $this->getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, 'en', 'UTF-8'); $this->_resource->BaseFont = new Zend_Pdf_Element_Name($baseFont); $this->_resource->FirstChar = new Zend_Pdf_Element_Numeric(0); $this->_resource->LastChar = new Zend_Pdf_Element_Numeric(count($this->_glyphWidths) - 1); $pdfWidths = array(); foreach ($this->_glyphWidths as $width) { $pdfWidths[] = new Zend_Pdf_Element_Numeric($this->toEmSpace($width)); } $widthsArrayElement = new Zend_Pdf_Element_Array($pdfWidths); $widthsObject = $this->_objectFactory->newObject($widthsArrayElement); $this->_resource->Widths = $widthsObject; } }

/* @source /library/Zend/Pdf.php */
class Zend_Pdf { const PDF_VERSION = '1.4'; const PDF_HEADER = "%PDF-1.4\n%\xE2\xE3\xCF\xD3\n"; public $pages = array(); public $properties = array(); protected $_originalProperties = array(); protected $_javaScript = null; protected $_namedTargets = array(); public $outlines = array(); protected $_originalOutlines = array(); protected $_originalOpenOutlinesCount = 0; protected $_trailer = null; protected $_objFactory = null; protected static $_memoryManager = null; protected $_parser; protected static $_inheritableAttributes = array('Resources', 'MediaBox', 'CropBox', 'Rotate'); protected $_isNewDocument = true; static public function getMemoryManager() { if (self::$_memoryManager === null) { self::$_memoryManager = Zend_Memory::factory('none'); } return self::$_memoryManager; } static public function setMemoryManager(Zend_Memory_Manager $memoryManager) { self::$_memoryManager = $memoryManager; } public static function parse(&$source = null, $revision = null) { return new Zend_Pdf($source, $revision); } public static function load($source = null, $revision = null) { return new Zend_Pdf($source, $revision, true); } public function save($filename, $updateOnly = false) { if (($file = @fopen($filename, $updateOnly ? 'ab':'wb')) === false ) { throw new Zend_Pdf_Exception( "Can not open '$filename' file for writing." ); } $this->render($updateOnly, $file); fclose($file); } public function __construct($source = null, $revision = null, $load = false) { $this->_objFactory = Zend_Pdf_ElementFactory::createFactory(1); if ($source !== null) { $this->_parser = new Zend_Pdf_Parser($source, $this->_objFactory, $load); $this->_pdfHeaderVersion = $this->_parser->getPDFVersion(); $this->_trailer = $this->_parser->getTrailer(); if ($this->_trailer->Encrypt !== null) { throw new Zend_Pdf_Exception('Encrypted document modification is not supported'); } if ($revision !== null) { $this->rollback($revision); } else { $this->_loadPages($this->_trailer->Root->Pages); } $this->_loadNamedDestinations($this->_trailer->Root, $this->_parser->getPDFVersion()); $this->_loadOutlines($this->_trailer->Root); if ($this->_trailer->Info !== null) { $this->properties = $this->_trailer->Info->toPhp(); if (isset($this->properties['Trapped'])) { switch ($this->properties['Trapped']) { case 'True': $this->properties['Trapped'] = true; break; case 'False': $this->properties['Trapped'] = false; break; case 'Unknown': $this->properties['Trapped'] = null; break; default: break; } } $this->_originalProperties = $this->properties; } $this->_isNewDocument = false; } else { $this->_pdfHeaderVersion = Zend_Pdf::PDF_VERSION; $trailerDictionary = new Zend_Pdf_Element_Dictionary(); $docId = md5(uniqid(rand(), true)); $docIdLow = substr($docId, 0, 16); $docIdHigh = substr($docId, 16, 16); $trailerDictionary->ID = new Zend_Pdf_Element_Array(); $trailerDictionary->ID->items[] = new Zend_Pdf_Element_String_Binary($docIdLow); $trailerDictionary->ID->items[] = new Zend_Pdf_Element_String_Binary($docIdHigh); $trailerDictionary->Size = new Zend_Pdf_Element_Numeric(0); $this->_trailer = new Zend_Pdf_Trailer_Generator($trailerDictionary); $docCatalog = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); $docCatalog->Type = new Zend_Pdf_Element_Name('Catalog'); $docCatalog->Version = new Zend_Pdf_Element_Name(Zend_Pdf::PDF_VERSION); $this->_trailer->Root = $docCatalog; $docPages = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); $docPages->Type = new Zend_Pdf_Element_Name('Pages'); $docPages->Kids = new Zend_Pdf_Element_Array(); $docPages->Count = new Zend_Pdf_Element_Numeric(0); $docCatalog->Pages = $docPages; } } public function revisions() { $revisions = 1; $currentTrailer = $this->_trailer; while ($currentTrailer->getPrev() !== null && $currentTrailer->getPrev()->Root !== null ) { $revisions++; $currentTrailer = $currentTrailer->getPrev(); } return $revisions++; } public function rollback($steps) { for ($count = 0; $count < $steps; $count++) { if ($this->_trailer->getPrev() !== null && $this->_trailer->getPrev()->Root !== null) { $this->_trailer = $this->_trailer->getPrev(); } else { break; } } $this->_objFactory->setObjectCount($this->_trailer->Size->value); $this->_trailer->Root->touch(); $this->pages = array(); $this->_loadPages($this->_trailer->Root->Pages); } protected function _loadPages(Zend_Pdf_Element_Reference $pages, $attributes = array()) { if ($pages->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Wrong argument'); } foreach ($pages->getKeys() as $property) { if (in_array($property, self::$_inheritableAttributes)) { $attributes[$property] = $pages->$property; $pages->$property = null; } } foreach ($pages->Kids->items as $child) { if ($child->Type->value == 'Pages') { $this->_loadPages($child, $attributes); } else if ($child->Type->value == 'Page') { foreach (self::$_inheritableAttributes as $property) { if ($child->$property === null && array_key_exists($property, $attributes)) { if ($attributes[$property] instanceof Zend_Pdf_Element_Object || $attributes[$property] instanceof Zend_Pdf_Element_Reference) { $child->$property = $attributes[$property]; } else { $child->$property = $this->_objFactory->newObject($attributes[$property]); } } } $this->pages[] = new Zend_Pdf_Page($child, $this->_objFactory); } } } protected function _loadNamedDestinations(Zend_Pdf_Element_Reference $root, $pdfHeaderVersion) { if ($root->Version !== null && version_compare($root->Version->value, $pdfHeaderVersion, '>')) { $versionIs_1_2_plus = version_compare($root->Version->value, '1.1', '>'); } else { $versionIs_1_2_plus = version_compare($pdfHeaderVersion, '1.1', '>'); } if ($versionIs_1_2_plus) { if ($root->Names !== null && $root->Names->Dests !== null) { foreach (new Zend_Pdf_NameTree($root->Names->Dests) as $name => $destination) { $this->_namedTargets[$name] = Zend_Pdf_Target::load($destination); } } } else { if ($root->Dests !== null) { if ($root->Dests->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Document catalog Dests entry must be a dictionary.'); } foreach ($root->Dests->getKeys() as $destKey) { $this->_namedTargets[$destKey] = Zend_Pdf_Target::load($root->Dests->$destKey); } } } } protected function _loadOutlines(Zend_Pdf_Element_Reference $root) { if ($root->Outlines === null) { return; } if ($root->Outlines->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Document catalog Outlines entry must be a dictionary.'); } if ($root->Outlines->Type !== null && $root->Outlines->Type->value != 'Outlines') { throw new Zend_Pdf_Exception('Outlines Type entry must be an \'Outlines\' string.'); } if ($root->Outlines->First === null) { return; } $outlineDictionary = $root->Outlines->First; $processedDictionaries = new SplObjectStorage(); while ($outlineDictionary !== null && !$processedDictionaries->contains($outlineDictionary)) { $processedDictionaries->attach($outlineDictionary); $this->outlines[] = new Zend_Pdf_Outline_Loaded($outlineDictionary); $outlineDictionary = $outlineDictionary->Next; } $this->_originalOutlines = $this->outlines; if ($root->Outlines->Count !== null) { $this->_originalOpenOutlinesCount = $root->Outlines->Count->value; } } protected function _dumpPages() { $root = $this->_trailer->Root; $pagesContainer = $root->Pages; $pagesContainer->touch(); $pagesContainer->Kids->items = array(); foreach ($this->pages as $page ) { $page->render($this->_objFactory); $pageDictionary = $page->getPageDictionary(); $pageDictionary->touch(); $pageDictionary->Parent = $pagesContainer; $pagesContainer->Kids->items[] = $pageDictionary; } $this->_refreshPagesHash(); $pagesContainer->Count->touch(); $pagesContainer->Count->value = count($this->pages); foreach ($this->_namedTargets as $name => $namedTarget) { if ($namedTarget instanceof Zend_Pdf_Destination_Explicit) { if ($this->resolveDestination($namedTarget, false) === null) { unset($this->_namedTargets[$name]); } } else if ($namedTarget instanceof Zend_Pdf_Action) { if ($this->_cleanUpAction($namedTarget, false) === null) { unset($this->_namedTargets[$name]); } } else { throw new Zend_Pdf_Exception('Wrong type of named targed (\'' . get_class($namedTarget) . '\').'); } } $iterator = new RecursiveIteratorIterator(new Zend_Pdf_RecursivelyIteratableObjectsContainer($this->outlines), RecursiveIteratorIterator::SELF_FIRST); foreach ($iterator as $outline) { $target = $outline->getTarget(); if ($target !== null) { if ($target instanceof Zend_Pdf_Destination) { if ($this->resolveDestination($target, false) === null) { $outline->setTarget(null); } } else if ($target instanceof Zend_Pdf_Action) { if ($this->_cleanUpAction($target, false) === null) { $outline->setTarget(null); } } else { throw new Zend_Pdf_Exception('Wrong outline target.'); } } } $openAction = $this->getOpenAction(); if ($openAction !== null) { if ($openAction instanceof Zend_Pdf_Action) { if ($this->_cleanUpAction($openAction, false) === null) { $this->setOpenAction(null); } } else if ($openAction instanceof Zend_Pdf_Destination) { if ($this->resolveDestination($openAction, false) === null) { $this->setOpenAction(null); } } else { throw new Zend_Pdf_Exception('OpenAction has to be either PDF Action or Destination.'); } } } protected function _dumpNamedDestinations() { ksort($this->_namedTargets, SORT_STRING); $destArrayItems = array(); foreach ($this->_namedTargets as $name => $destination) { $destArrayItems[] = new Zend_Pdf_Element_String($name); if ($destination instanceof Zend_Pdf_Target) { $destArrayItems[] = $destination->getResource(); } else { throw new Zend_Pdf_Exception('PDF named destinations must be a Zend_Pdf_Target object.'); } } $destArray = $this->_objFactory->newObject(new Zend_Pdf_Element_Array($destArrayItems)); $DestTree = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); $DestTree->Names = $destArray; $root = $this->_trailer->Root; if ($root->Names === null) { $root->touch(); $root->Names = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); } else { $root->Names->touch(); } $root->Names->Dests = $DestTree; } protected function _dumpOutlines() { $root = $this->_trailer->Root; if ($root->Outlines === null) { if (count($this->outlines) == 0) { return; } else { $root->Outlines = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); $root->Outlines->Type = new Zend_Pdf_Element_Name('Outlines'); $updateOutlinesNavigation = true; } } else { $updateOutlinesNavigation = false; if (count($this->_originalOutlines) != count($this->outlines)) { $updateOutlinesNavigation = true; } else if ( !(array_keys($this->_originalOutlines) === array_keys($this->outlines)) ) { $updateOutlinesNavigation = true; } else { foreach ($this->outlines as $key => $outline) { if ($this->_originalOutlines[$key] !== $outline) { $updateOutlinesNavigation = true; } } } } $lastOutline = null; $openOutlinesCount = 0; if ($updateOutlinesNavigation) { $root->Outlines->touch(); $root->Outlines->First = null; foreach ($this->outlines as $outline) { if ($lastOutline === null) { $lastOutline = $outline->dumpOutline($this->_objFactory, $updateOutlinesNavigation, $root->Outlines); $root->Outlines->First = $lastOutline; } else { $currentOutlineDictionary = $outline->dumpOutline($this->_objFactory, $updateOutlinesNavigation, $root->Outlines, $lastOutline); $lastOutline->Next = $currentOutlineDictionary; $lastOutline = $currentOutlineDictionary; } $openOutlinesCount += $outline->openOutlinesCount(); } $root->Outlines->Last = $lastOutline; } else { foreach ($this->outlines as $outline) { $lastOutline = $outline->dumpOutline($this->_objFactory, $updateOutlinesNavigation, $root->Outlines, $lastOutline); $openOutlinesCount += $outline->openOutlinesCount(); } } if ($openOutlinesCount != $this->_originalOpenOutlinesCount) { $root->Outlines->touch; $root->Outlines->Count = new Zend_Pdf_Element_Numeric($openOutlinesCount); } } public function newPage($param1, $param2 = null) { if ($param2 === null) { return new Zend_Pdf_Page($param1, $this->_objFactory); } else { return new Zend_Pdf_Page($param1, $param2, $this->_objFactory); } } public function getMetadata() { if ($this->_trailer->Root->Metadata !== null) { return $this->_trailer->Root->Metadata->value; } else { return null; } } public function setMetadata($metadata) { $metadataObject = $this->_objFactory->newStreamObject($metadata); $metadataObject->dictionary->Type = new Zend_Pdf_Element_Name('Metadata'); $metadataObject->dictionary->Subtype = new Zend_Pdf_Element_Name('XML'); $this->_trailer->Root->Metadata = $metadataObject; $this->_trailer->Root->touch(); } public function getJavaScript() { return $this->_javaScript; } public function getOpenAction() { if ($this->_trailer->Root->OpenAction !== null) { return Zend_Pdf_Target::load($this->_trailer->Root->OpenAction); } else { return null; } } public function setOpenAction(Zend_Pdf_Target $openAction = null) { $root = $this->_trailer->Root; $root->touch(); if ($openAction === null) { $root->OpenAction = null; } else { $root->OpenAction = $openAction->getResource(); if ($openAction instanceof Zend_Pdf_Action) { $openAction->dumpAction($this->_objFactory); } } return $this; } public function getNamedDestinations() { return $this->_namedTargets; } public function getNamedDestination($name) { if (isset($this->_namedTargets[$name])) { return $this->_namedTargets[$name]; } else { return null; } } public function setNamedDestination($name, $destination = null) { if ($destination !== null && !$destination instanceof Zend_Pdf_Action_GoTo && !$destination instanceof Zend_Pdf_Destination_Explicit) { throw new Zend_Pdf_Exception('PDF named destination must refer an explicit destination or a GoTo PDF action.'); } if ($destination !== null) { $this->_namedTargets[$name] = $destination; } else { unset($this->_namedTargets[$name]); } } protected $_pageReferences = null; protected $_pageNumbers = null; protected function _refreshPagesHash() { $this->_pageReferences = array(); $this->_pageNumbers = array(); $count = 1; foreach ($this->pages as $page) { $pageDictionaryHashId = spl_object_hash($page->getPageDictionary()->getObject()); $this->_pageReferences[$pageDictionaryHashId] = $page; $this->_pageNumbers[$count++] = $page; } return $this; } public function resolveDestination(Zend_Pdf_Destination $destination, $refreshPageCollectionHashes = true) { if ($this->_pageReferences === null || $refreshPageCollectionHashes) { $this->_refreshPagesHash(); } if ($destination instanceof Zend_Pdf_Destination_Named) { if (!isset($this->_namedTargets[$destination->getName()])) { return null; } $destination = $this->getNamedDestination($destination->getName()); if ($destination instanceof Zend_Pdf_Action) { if (!$destination instanceof Zend_Pdf_Action_GoTo) { return null; } $destination = $destination->getDestination(); } if (!$destination instanceof Zend_Pdf_Destination_Explicit) { throw new Zend_Pdf_Exception('Named destination target has to be an explicit destination.'); } } $pageElement = $destination->getResource()->items[0]; if ($pageElement->getType() == Zend_Pdf_Element::TYPE_NUMERIC) { if (!isset($this->_pageNumbers[$pageElement->value])) { return null; } return $this->_pageNumbers[$pageElement->value]; } $pageDictionaryHashId = spl_object_hash($pageElement->getObject()); if (!isset($this->_pageReferences[$pageDictionaryHashId])) { return null; } return $this->_pageReferences[$pageDictionaryHashId]; } protected function _cleanUpAction(Zend_Pdf_Action $action, $refreshPageCollectionHashes = true) { if ($this->_pageReferences === null || $refreshPageCollectionHashes) { $this->_refreshPagesHash(); } if ($action instanceof Zend_Pdf_Action_GoTo && $this->resolveDestination($action->getDestination(), false) === null) { return null; } $iterator = new RecursiveIteratorIterator($action, RecursiveIteratorIterator::SELF_FIRST); $actionsToClean = array(); $deletionCandidateKeys = array(); foreach ($iterator as $chainedAction) { if ($chainedAction instanceof Zend_Pdf_Action_GoTo && $this->resolveDestination($chainedAction->getDestination(), false) === null) { $actionsToClean[] = $iterator->getSubIterator(); $deletionCandidateKeys[] = $iterator->getSubIterator()->key(); } } foreach ($actionsToClean as $id => $action) { unset($action->next[$deletionCandidateKeys[$id]]); } return $action; } public function extractFonts() { $fontResourcesUnique = array(); foreach ($this->pages as $page) { $pageResources = $page->extractResources(); if ($pageResources->Font === null) { continue; } $fontResources = $pageResources->Font; foreach ($fontResources->getKeys() as $fontResourceName) { $fontDictionary = $fontResources->$fontResourceName; if (! ($fontDictionary instanceof Zend_Pdf_Element_Reference || $fontDictionary instanceof Zend_Pdf_Element_Object) ) { throw new Zend_Pdf_Exception('Font dictionary has to be an indirect object or object reference.'); } $fontResourcesUnique[spl_object_hash($fontDictionary->getObject())] = $fontDictionary; } } $fonts = array(); foreach ($fontResourcesUnique as $resourceId => $fontDictionary) { try { $extractedFont = new Zend_Pdf_Resource_Font_Extracted($fontDictionary); $fonts[$resourceId] = $extractedFont; } catch (Zend_Pdf_Exception $e) { if ($e->getMessage() != 'Unsupported font type.') { throw $e; } } } return $fonts; } public function extractFont($fontName) { $fontResourcesUnique = array(); foreach ($this->pages as $page) { $pageResources = $page->extractResources(); if ($pageResources->Font === null) { continue; } $fontResources = $pageResources->Font; foreach ($fontResources->getKeys() as $fontResourceName) { $fontDictionary = $fontResources->$fontResourceName; if (! ($fontDictionary instanceof Zend_Pdf_Element_Reference || $fontDictionary instanceof Zend_Pdf_Element_Object) ) { throw new Zend_Pdf_Exception('Font dictionary has to be an indirect object or object reference.'); } $resourceId = spl_object_hash($fontDictionary->getObject()); if (isset($fontResourcesUnique[$resourceId])) { continue; } else { $fontResourcesUnique[$resourceId] = 1; } if ($fontDictionary->BaseFont->value != $fontName) { continue; } try { return new Zend_Pdf_Resource_Font_Extracted($fontDictionary); } catch (Zend_Pdf_Exception $e) { if ($e->getMessage() != 'Unsupported font type.') { throw $e; } } } } return null; } public function render($newSegmentOnly = false, $outputStream = null) { if ($this->_isNewDocument) { $newSegmentOnly = false; $this->_isNewDocument = false; } if ($this->properties != $this->_originalProperties) { $docInfo = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); foreach ($this->properties as $key => $value) { switch ($key) { case 'Trapped': switch ($value) { case true: $docInfo->$key = new Zend_Pdf_Element_Name('True'); break; case false: $docInfo->$key = new Zend_Pdf_Element_Name('False'); break; case null: $docInfo->$key = new Zend_Pdf_Element_Name('Unknown'); break; default: throw new Zend_Pdf_Exception('Wrong Trapped document property vale: \'' . $value . '\'. Only true, false and null values are allowed.'); break; } case 'CreationDate': case 'ModDate': $docInfo->$key = new Zend_Pdf_Element_String((string)$value); break; case 'Title': case 'Author': case 'Subject': case 'Keywords': case 'Creator': case 'Producer': if (extension_loaded('mbstring') === true) { $detected = mb_detect_encoding($value); if ($detected !== 'ASCII') { $value = "\xfe\xff" . mb_convert_encoding($value, 'UTF-16', $detected); } } $docInfo->$key = new Zend_Pdf_Element_String((string)$value); break; default: $docInfo->$key = Zend_Pdf_Element::phpToPdf($value); break; } } $this->_trailer->Info = $docInfo; } $this->_dumpPages(); $this->_dumpNamedDestinations(); $this->_dumpOutlines(); if (!$this->_objFactory->isModified()) { if ($newSegmentOnly) { return ''; } if ($outputStream === null) { return $this->_trailer->getPDFString(); } else { $pdfData = $this->_trailer->getPDFString(); while ( strlen($pdfData) > 0 && ($byteCount = fwrite($outputStream, $pdfData)) != false ) { $pdfData = substr($pdfData, $byteCount); } return ''; } } $offset = $this->_trailer->getPDFLength(); $lastFreeObject = $this->_trailer->getLastFreeObject(); $xrefTable = array(); $xrefSectionStartNums = array(); $xrefSection = array(); $xrefSection[] = 0; $xrefSectionStartNums[] = 0; $lastObjNum = 0; if ($outputStream !== null) { if (!$newSegmentOnly) { $pdfData = $this->_trailer->getPDFString(); while ( strlen($pdfData) > 0 && ($byteCount = fwrite($outputStream, $pdfData)) != false ) { $pdfData = substr($pdfData, $byteCount); } } } else { $pdfSegmentBlocks = ($newSegmentOnly) ? array() : array($this->_trailer->getPDFString()); } foreach ($this->_objFactory->listModifiedObjects() as $updateInfo) { $objNum = $updateInfo->getObjNum(); if ($objNum - $lastObjNum != 1) { $xrefTable[] = $xrefSection; $xrefSection = array(); $xrefSectionStartNums[] = $objNum; } if ($updateInfo->isFree()) { $xrefSection[] = sprintf("%010d %05d f \n", $lastFreeObject, $updateInfo->getGenNum()); $lastFreeObject = $objNum; } else { $xrefSection[] = sprintf("%010d %05d n \n", $offset, $updateInfo->getGenNum()); $pdfBlock = $updateInfo->getObjectDump(); $offset += strlen($pdfBlock); if ($outputStream === null) { $pdfSegmentBlocks[] = $pdfBlock; } else { while ( strlen($pdfBlock) > 0 && ($byteCount = fwrite($outputStream, $pdfBlock)) != false ) { $pdfBlock = substr($pdfBlock, $byteCount); } } } $lastObjNum = $objNum; } $xrefTable[] = $xrefSection; $xrefTable[0][0] = sprintf("%010d 65535 f \n", $lastFreeObject); $xrefTableStr = "xref\n"; foreach ($xrefTable as $sectId => $xrefSection) { $xrefTableStr .= sprintf("%d %d \n", $xrefSectionStartNums[$sectId], count($xrefSection)); foreach ($xrefSection as $xrefTableEntry) { $xrefTableStr .= $xrefTableEntry; } } $this->_trailer->Size->value = $this->_objFactory->getObjectCount(); $pdfBlock = $xrefTableStr . $this->_trailer->toString() . "startxref\n" . $offset . "\n" . "%%EOF\n"; $this->_objFactory->cleanEnumerationShiftCache(); if ($outputStream === null) { $pdfSegmentBlocks[] = $pdfBlock; return implode('', $pdfSegmentBlocks); } else { while ( strlen($pdfBlock) > 0 && ($byteCount = fwrite($outputStream, $pdfBlock)) != false ) { $pdfBlock = substr($pdfBlock, $byteCount); } return ''; } } public function setJavaScript($javascript) { $this->_javaScript = $javascript; } public static function pdfDate($timestamp = null) { if ($timestamp === null) { $date = date('\D\:YmdHisO'); } else { $date = date('\D\:YmdHisO', $timestamp); } return substr_replace($date, '\'', -2, 0) . '\''; } }

/* @source /library/Zend/Pdf/Canvas.php */
class Zend_Pdf_Canvas extends Zend_Pdf_Canvas_Abstract { protected $_procSet = array(); protected $_width; protected $_height; protected $_resources = array('Font' => array(), 'XObject' => array(), 'ExtGState' => array()); public function __construct($width, $height) { $this->_width = $width; $this->_height = $height; } protected function _addProcSet($procSetName) { $this->_procset[$procSetName] = 1; } protected function _attachResource($type, Zend_Pdf_Resource $resource) { $resObject = $resource->getResource(); foreach ($this->_resources[$type] as $resName => $collectedResObject) { if ($collectedResObject === $resObject) { return $resName; } } $idCounter = 1; do { $newResName = $type[0] . $idCounter++; } while (isset($this->_resources[$type][$newResName])); $this->_resources[$type][$newResName] = $resObject; return $newResName; } public function getResources() { $this->_resources['ProcSet'] = array_keys($this->_procSet); return $this->_resources; } public function getContents() { } public function getHeight() { return $this->_height; } public function getWidth() { return $this->_width; } }

/* @source /library/Zend/Pdf/ElementFactory.php */
class Zend_Pdf_ElementFactory implements Zend_Pdf_ElementFactory_Interface { private $_modifiedObjects = array(); private $_removedObjects; private $_registeredObjects = array(); private $_objectCount; private $_attachedFactories = array(); private $_factoryId; private static $_identity = 0; private $_shiftCalculationCache = array(); public function __construct($objCount) { $this->_objectCount = (int)$objCount; $this->_factoryId = self::$_identity++; $this->_removedObjects = new SplObjectStorage(); } public function getFactory() { return $this; } static public function createFactory($objCount) { return new Zend_Pdf_ElementFactory_Proxy(new Zend_Pdf_ElementFactory($objCount)); } public function close() { $this->_modifiedObjects = null; $this->_removedObjects = null; $this->_attachedFactories = null; foreach ($this->_registeredObjects as $obj) { $obj->cleanUp(); } $this->_registeredObjects = null; } public function resolve() { return $this; } public function getId() { return $this->_factoryId; } public function setObjectCount($objCount) { $this->_objectCount = (int)$objCount; } public function getObjectCount() { $count = $this->_objectCount; foreach ($this->_attachedFactories as $attached) { $count += $attached->getObjectCount() - 1; } return $count; } public function attach(Zend_Pdf_ElementFactory_Interface $factory) { if ( $factory === $this || isset($this->_attachedFactories[$factory->getId()])) { return; } $this->_attachedFactories[$factory->getId()] = $factory; } public function calculateShift(Zend_Pdf_ElementFactory_Interface $factory) { if ($factory === $this) { return 0; } if (isset($this->_shiftCalculationCache[$factory->_factoryId])) { return $this->_shiftCalculationCache[$factory->_factoryId]; } $shift = $this->_objectCount - 1; foreach ($this->_attachedFactories as $subFactory) { $subFactoryShift = $subFactory->calculateShift($factory); if ($subFactoryShift != -1) { $this->_shiftCalculationCache[$factory->_factoryId] = $shift + $subFactoryShift; return $shift + $subFactoryShift; } else { $shift += $subFactory->getObjectCount()-1; } } $this->_shiftCalculationCache[$factory->_factoryId] = -1; return -1; } public function cleanEnumerationShiftCache() { $this->_shiftCalculationCache = array(); foreach ($this->_attachedFactories as $attached) { $attached->cleanEnumerationShiftCache(); } } public function getEnumerationShift(Zend_Pdf_ElementFactory_Interface $factory) { if (($shift = $this->calculateShift($factory)) == -1) { throw new Zend_Pdf_Exception('Wrong object context'); } return $shift; } public function markAsModified(Zend_Pdf_Element_Object $obj) { if ($obj->getFactory() !== $this) { throw new Zend_Pdf_Exception('Object is not generated by this factory'); } $this->_modifiedObjects[$obj->getObjNum()] = $obj; } public function remove(Zend_Pdf_Element_Object $obj) { if (!$obj->compareFactory($this)) { throw new Zend_Pdf_Exception('Object is not generated by this factory'); } $this->_modifiedObjects[$obj->getObjNum()] = $obj; $this->_removedObjects->attach($obj); } public function newObject(Zend_Pdf_Element $objectValue) { $obj = new Zend_Pdf_Element_Object($objectValue, $this->_objectCount++, 0, $this); $this->_modifiedObjects[$obj->getObjNum()] = $obj; return $obj; } public function newStreamObject($streamValue) { $obj = new Zend_Pdf_Element_Object_Stream($streamValue, $this->_objectCount++, 0, $this); $this->_modifiedObjects[$obj->getObjNum()] = $obj; return $obj; } public function listModifiedObjects($rootFactory = null) { if ($rootFactory == null) { $rootFactory = $this; $shift = 0; } else { $shift = $rootFactory->getEnumerationShift($this); } ksort($this->_modifiedObjects); $result = array(); foreach ($this->_modifiedObjects as $objNum => $obj) { if ($this->_removedObjects->contains($obj)) { $result[$objNum+$shift] = new Zend_Pdf_UpdateInfoContainer($objNum + $shift, $obj->getGenNum()+1, true); } else { $result[$objNum+$shift] = new Zend_Pdf_UpdateInfoContainer($objNum + $shift, $obj->getGenNum(), false, $obj->dump($rootFactory)); } } foreach ($this->_attachedFactories as $factory) { $result += $factory->listModifiedObjects($rootFactory); } return $result; } public function registerObject(Zend_Pdf_Element_Object $obj, $refString) { $this->_registeredObjects[$refString] = $obj; } public function fetchObject($refString) { if (!isset($this->_registeredObjects[$refString])) { return null; } return $this->_registeredObjects[$refString]; } public function isModified() { if (count($this->_modifiedObjects) != 0) { return true; } foreach ($this->_attachedFactories as $subFactory) { if ($subFactory->isModified()) { return true; } } return false; } }

/* @source /library/Zend/Pdf/Exception.php */
class Zend_Pdf_Exception extends Zend_Exception { const NOT_IMPLEMENTED = 0x0001; const DEPRECATED = 0x0002; const TOO_FEW_PARAMETERS = 0x0003; const BAD_PARAMETER_TYPE = 0x0004; const BAD_PARAMETER_VALUE = 0x0005; const PARAMETER_VALUE_OUT_OF_RANGE = 0x0006; const BAD_METHOD_SIGNATURE = 0x0007; const INDEX_OUT_OF_RANGE = 0x0008; const BAD_FILE_PATH = 0x0101; const NOT_READABLE = 0x0102; const NOT_WRITEABLE = 0x0103; const FILE_NOT_OPEN = 0x0104; const CANT_OPEN_FILE = 0x0105; const CANT_GET_FILE_POSITION = 0x0106; const CANT_SET_FILE_POSITION = 0x0107; const MOVE_BEFORE_START_OF_FILE = 0x0108; const MOVE_BEYOND_END_OF_FILE = 0x0109; const CANT_GET_FILE_SIZE = 0x010a; const ERROR_DURING_READ = 0x010b; const ERROR_DURING_WRITE = 0x010c; const INVALID_PAGE_SIZE = 0x010d; const INSUFFICIENT_DATA = 0x010e; const BAD_DATA_SOURCE = 0x0201; const INVALID_BYTE_ORDER = 0x0202; const INVALID_INTEGER_SIZE = 0x0203; const BAD_FIXED_POINT_SIZE = 0x0204; const CANT_READ_STRING = 0x0205; const PARSED_OUT_OF_ORDER = 0x0206; const WRONG_FONT_TYPE = 0x0301; const BAD_TABLE_COUNT = 0x0302; const REQUIRED_TABLE_NOT_FOUND = 0x0303; const DONT_UNDERSTAND_TABLE_VERSION = 0x0303; const BAD_MAGIC_NUMBER = 0x0304; const CANT_FIND_GOOD_CMAP = 0x0305; const CMAP_TYPE_UNSUPPORTED = 0x0401; const CMAP_UNKNOWN_TYPE = 0x0402; const CMAP_TABLE_DATA_TOO_SMALL = 0x0403; const CMAP_WRONG_TABLE_TYPE = 0x0404; const CMAP_WRONG_TABLE_LENGTH = 0x0405; const CMAP_NOT_LANGUAGE_INDEPENDENT = 0x0406; const CMAP_FINAL_OFFSET_NOT_LENGTH = 0x0407; const CMAP_WRONG_ENTRY_COUNT = 0x0408; const GLYPH_OUT_OF_RANGE = 0x0501; const FONT_CANT_BE_EMBEDDED = 0x0502; const BAD_FONT_NAME = 0x0601; const CANT_DETERMINE_FONT_TYPE = 0x0602; const BAD_ATTRIBUTE_VALUE = 0x0701; const CANT_DETERMINE_IMAGE_TYPE = 0x0801; const WRONG_IMAGE_TYPE = 0x0802; const UNSUPPORTED_IMAGE_ENCODING_OPTIONS = 0x0803; const IMAGE_FILE_CORRUPT = 0x0804; }

/* @source /library/Zend/Pdf/UpdateInfoContainer.php */
class Zend_Pdf_UpdateInfoContainer { private $_objNum; private $_genNum; private $_isFree; private $_dump = null; public function __construct($objNum, $genNum, $isFree, $dump = null) { $this->_objNum = $objNum; $this->_genNum = $genNum; $this->_isFree = $isFree; if ($dump !== null) { $this->_dump = $dump; } } public function getObjNum() { return $this->_objNum; } public function getGenNum() { return $this->_genNum; } public function isFree() { return $this->_isFree; } public function getObjectDump() { if ($this->_dump === null) { return ''; } if (is_string($this->_dump)) { return $this->_dump; } return $this->_dump->getRef(); } }

/* @source /library/Zend/Pdf/RecursivelyIteratableObjectsContainer.php */
class Zend_Pdf_RecursivelyIteratableObjectsContainer implements RecursiveIterator, Countable { protected $_objects = array(); public function __construct(array $objects) { $this->_objects = $objects; } public function current() { return current($this->_objects); } public function key() { return key($this->_objects); } public function next() { return next($this->_objects); } public function rewind() { return reset($this->_objects); } public function valid() { return current($this->_objects) !== false; } public function getChildren() { return current($this->_objects); } public function hasChildren() { return count($this->_objects) > 0; } public function count() { return count($this->_objects); } }

/* @source /library/Zend/Pdf/Page.php */
class Zend_Pdf_Page extends Zend_Pdf_Canvas_Abstract { const SIZE_A4 = '595:842:'; const SIZE_A4_LANDSCAPE = '842:595:'; const SIZE_LETTER = '612:792:'; const SIZE_LETTER_LANDSCAPE = '792:612:'; const SHAPE_DRAW_STROKE = 0; const SHAPE_DRAW_FILL = 1; const SHAPE_DRAW_FILL_AND_STROKE = 2; const FILL_METHOD_NON_ZERO_WINDING = 0; const FILL_METHOD_EVEN_ODD = 1; const LINE_DASHING_SOLID = 0; protected $_dictionary; protected $_objFactory = null; protected $_attached; protected $_safeGS; public function __construct($param1, $param2 = null, $param3 = null) { if (($param1 instanceof Zend_Pdf_Element_Reference || $param1 instanceof Zend_Pdf_Element_Object ) && $param2 instanceof Zend_Pdf_ElementFactory_Interface && $param3 === null ) { switch ($param1->getType()) { case Zend_Pdf_Element::TYPE_DICTIONARY: $this->_dictionary = $param1; $this->_objFactory = $param2; $this->_attached = true; $this->_safeGS = false; return; break; case Zend_Pdf_Element::TYPE_NULL: $this->_objFactory = $param2; $pageWidth = $pageHeight = 0; break; default: throw new Zend_Pdf_Exception('Unrecognized object type.'); break; } } else if ($param1 instanceof Zend_Pdf_Page && $param2 === null && $param3 === null) { $this->_objFactory = $param1->_objFactory; $this->_attached = &$param1->_attached; $this->_safeGS = false; $this->_dictionary = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); foreach ($param1->_dictionary->getKeys() as $key) { if ($key == 'Contents') { $this->_dictionary->Contents = new Zend_Pdf_Element_Array(); if ($param1->_dictionary->Contents->getType() != Zend_Pdf_Element::TYPE_ARRAY) { $this->_dictionary->Contents->items[] = $param1->_dictionary->Contents; } else { foreach ($param1->_dictionary->Contents->items as $srcContentStream) { $this->_dictionary->Contents->items[] = $srcContentStream; } } } else { $this->_dictionary->$key = $param1->_dictionary->$key; } } return; } else if (is_string($param1) && ($param2 === null || $param2 instanceof Zend_Pdf_ElementFactory_Interface) && $param3 === null) { if ($param2 !== null) { $this->_objFactory = $param2; } else { $this->_objFactory = Zend_Pdf_ElementFactory::createFactory(1); } $this->_attached = false; $this->_safeGS = true; switch (strtolower($param1)) { case 'a4': $param1 = Zend_Pdf_Page::SIZE_A4; break; case 'a4-landscape': $param1 = Zend_Pdf_Page::SIZE_A4_LANDSCAPE; break; case 'letter': $param1 = Zend_Pdf_Page::SIZE_LETTER; break; case 'letter-landscape': $param1 = Zend_Pdf_Page::SIZE_LETTER_LANDSCAPE; break; default: } $pageDim = explode(':', $param1); if(count($pageDim) == 2 || count($pageDim) == 3) { $pageWidth = $pageDim[0]; $pageHeight = $pageDim[1]; } else { throw new Zend_Pdf_Exception('Wrong pagesize notation.'); } } else if (is_numeric($param1) && is_numeric($param2) && ($param3 === null || $param3 instanceof Zend_Pdf_ElementFactory_Interface)) { if ($param3 !== null) { $this->_objFactory = $param3; } else { $this->_objFactory = Zend_Pdf_ElementFactory::createFactory(1); } $this->_attached = false; $this->_safeGS = true; $pageWidth = $param1; $pageHeight = $param2; } else { throw new Zend_Pdf_Exception('Unrecognized method signature, wrong number of arguments or wrong argument types.'); } $this->_dictionary = $this->_objFactory->newObject(new Zend_Pdf_Element_Dictionary()); $this->_dictionary->Type = new Zend_Pdf_Element_Name('Page'); $this->_dictionary->LastModified = new Zend_Pdf_Element_String(Zend_Pdf::pdfDate()); $this->_dictionary->Resources = new Zend_Pdf_Element_Dictionary(); $this->_dictionary->MediaBox = new Zend_Pdf_Element_Array(); $this->_dictionary->MediaBox->items[] = new Zend_Pdf_Element_Numeric(0); $this->_dictionary->MediaBox->items[] = new Zend_Pdf_Element_Numeric(0); $this->_dictionary->MediaBox->items[] = new Zend_Pdf_Element_Numeric($pageWidth); $this->_dictionary->MediaBox->items[] = new Zend_Pdf_Element_Numeric($pageHeight); $this->_dictionary->Contents = new Zend_Pdf_Element_Array(); } protected function _attachResource($type, Zend_Pdf_Resource $resource) { if ($this->_dictionary->Resources->$type === null) { $this->_dictionary->Resources->touch(); $this->_dictionary->Resources->$type = new Zend_Pdf_Element_Dictionary(); } else { $this->_dictionary->Resources->$type->touch(); } $resObject = $resource->getResource(); foreach ($this->_dictionary->Resources->$type->getKeys() as $ResID) { if ($this->_dictionary->Resources->$type->$ResID === $resObject) { return $ResID; } } $idCounter = 1; do { $newResName = $type[0] . $idCounter++; } while ($this->_dictionary->Resources->$type->$newResName !== null); $this->_dictionary->Resources->$type->$newResName = $resObject; $this->_objFactory->attach($resource->getFactory()); return $newResName; } protected function _addProcSet($procSetName) { if ($this->_dictionary->Resources->ProcSet === null) { $this->_dictionary->Resources->touch(); $this->_dictionary->Resources->ProcSet = new Zend_Pdf_Element_Array(); } else { $this->_dictionary->Resources->ProcSet->touch(); } foreach ($this->_dictionary->Resources->ProcSet->items as $procSetEntry) { if ($procSetEntry->value == $procSetName) { return; } } $this->_dictionary->Resources->ProcSet->items[] = new Zend_Pdf_Element_Name($procSetName); } public function getResources() { $resources = array(); $resDictionary = $this->_dictionary->Resources; foreach ($resDictionary->getKeys() as $resType) { $resources[$resType] = array(); if ($resType == 'ProcSet') { foreach ($resDictionary->ProcSet->items as $procSetEntry) { $resources[$resType][] = $procSetEntry->value; } } else { $resMap = $resDictionary->$resType; foreach ($resMap->getKeys() as $resId) { $resources[$resType][$resId] =new Zend_Pdf_Resource_Unified($resMap->$resId); } } } return $resources; } public function getContents() { } public function getHeight() { return $this->_dictionary->MediaBox->items[3]->value - $this->_dictionary->MediaBox->items[1]->value; } public function getWidth() { return $this->_dictionary->MediaBox->items[2]->value - $this->_dictionary->MediaBox->items[0]->value; } public function __clone() { $factory = Zend_Pdf_ElementFactory::createFactory(1); $processed = array(); $dictionary = new Zend_Pdf_Element_Dictionary(); foreach ($this->_dictionary->getKeys() as $key) { $dictionary->$key = $this->_dictionary->$key->makeClone($factory->getFactory(), $processed, Zend_Pdf_Element::CLONE_MODE_SKIP_PAGES); } $this->_dictionary = $factory->newObject($dictionary); $this->_objFactory = $factory; $this->_attached = false; $this->_style = null; $this->_font = null; } public function clonePage($factory, &$processed) { $dictionary = new Zend_Pdf_Element_Dictionary(); foreach ($this->_dictionary->getKeys() as $key) { $dictionary->$key = $this->_dictionary->$key->makeClone($factory->getFactory(), $processed, Zend_Pdf_Element::CLONE_MODE_SKIP_PAGES); } $clonedPage = new Zend_Pdf_Page($factory->newObject($dictionary), $factory); $clonedPage->_attached = false; return $clonedPage; } public function getPageDictionary() { return $this->_dictionary; } public function flush() { if ($this->_saveCount != 0) { throw new Zend_Pdf_Exception('Saved graphics state is not restored'); } if ($this->_contents == '') { return; } if ($this->_dictionary->Contents->getType() != Zend_Pdf_Element::TYPE_ARRAY) { $this->_dictionary->touch(); $currentPageContents = $this->_dictionary->Contents; $this->_dictionary->Contents = new Zend_Pdf_Element_Array(); $this->_dictionary->Contents->items[] = $currentPageContents; } else { $this->_dictionary->Contents->touch(); } if ((!$this->_safeGS) && (count($this->_dictionary->Contents->items) != 0)) { $this->_addProcSet('PDF'); $newContentsArray = new Zend_Pdf_Element_Array(); $newContentsArray->items[] = $this->_objFactory->newStreamObject(" q\n"); foreach ($this->_dictionary->Contents->items as $contentStream) { $newContentsArray->items[] = $contentStream; } $newContentsArray->items[] = $this->_objFactory->newStreamObject(" Q\n"); $this->_dictionary->touch(); $this->_dictionary->Contents = $newContentsArray; $this->_safeGS = true; } $this->_dictionary->Contents->items[] = $this->_objFactory->newStreamObject($this->_contents); $this->_contents = ''; } public function render(Zend_Pdf_ElementFactory_Interface $objFactory) { $this->flush(); if ($objFactory === $this->_objFactory) { return; } if ($this->_attached) { throw new Zend_Pdf_Exception('Page is attached to other documen. Use clone $page to get it context free.'); } else { $objFactory->attach($this->_objFactory); } } public function extractResources() { return $this->_dictionary->Resources; } public function extractFonts() { if ($this->_dictionary->Resources->Font === null) { return array(); } $fontResources = $this->_dictionary->Resources->Font; $fontResourcesUnique = array(); foreach ($fontResources->getKeys() as $fontResourceName) { $fontDictionary = $fontResources->$fontResourceName; if (! ($fontDictionary instanceof Zend_Pdf_Element_Reference || $fontDictionary instanceof Zend_Pdf_Element_Object) ) { throw new Zend_Pdf_Exception('Font dictionary has to be an indirect object or object reference.'); } $fontResourcesUnique[spl_object_hash($fontDictionary->getObject())] = $fontDictionary; } $fonts = array(); foreach ($fontResourcesUnique as $resourceId => $fontDictionary) { try { $extractedFont = new Zend_Pdf_Resource_Font_Extracted($fontDictionary); $fonts[$resourceId] = $extractedFont; } catch (Zend_Pdf_Exception $e) { if ($e->getMessage() != 'Unsupported font type.') { throw new Zend_Pdf_Exception($e->getMessage(), $e->getCode(), $e); } } } return $fonts; } public function extractFont($fontName) { if ($this->_dictionary->Resources->Font === null) { return null; } $fontResources = $this->_dictionary->Resources->Font; $fontResourcesUnique = array(); foreach ($fontResources->getKeys() as $fontResourceName) { $fontDictionary = $fontResources->$fontResourceName; if (! ($fontDictionary instanceof Zend_Pdf_Element_Reference || $fontDictionary instanceof Zend_Pdf_Element_Object) ) { throw new Zend_Pdf_Exception('Font dictionary has to be an indirect object or object reference.'); } $resourceId = spl_object_hash($fontDictionary->getObject()); if (isset($fontResourcesUnique[$resourceId])) { continue; } else { $fontResourcesUnique[$resourceId] = 1; } if ($fontDictionary->BaseFont->value != $fontName) { continue; } try { return new Zend_Pdf_Resource_Font_Extracted($fontDictionary); } catch (Zend_Pdf_Exception $e) { if ($e->getMessage() != 'Unsupported font type.') { throw new Zend_Pdf_Exception($e->getMessage(), $e->getCode(), $e); } } } return null; } public function attachAnnotation(Zend_Pdf_Annotation $annotation) { $annotationDictionary = $annotation->getResource(); if (!$annotationDictionary instanceof Zend_Pdf_Element_Object && !$annotationDictionary instanceof Zend_Pdf_Element_Reference) { $annotationDictionary = $this->_objFactory->newObject($annotationDictionary); } if ($this->_dictionary->Annots === null) { $this->_dictionary->touch(); $this->_dictionary->Annots = new Zend_Pdf_Element_Array(); } else { $this->_dictionary->Annots->touch(); } $this->_dictionary->Annots->items[] = $annotationDictionary; $annotationDictionary->touch(); $annotationDictionary->P = $this->_dictionary; return $this; } }

/* @source /library/Zend/Pdf/NameTree.php */
class Zend_Pdf_NameTree implements ArrayAccess, Iterator, Countable { protected $_items = array(); public function __construct(Zend_Pdf_Element $rootDictionary) { if ($rootDictionary->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Name tree root must be a dictionary.'); } $intermediateNodes = array(); $leafNodes = array(); if ($rootDictionary->Kids !== null) { $intermediateNodes[] = $rootDictionary; } else { $leafNodes[] = $rootDictionary; } while (count($intermediateNodes) != 0) { $newIntermediateNodes = array(); foreach ($intermediateNodes as $node) { foreach ($node->Kids->items as $childNode) { if ($childNode->Kids !== null) { $newIntermediateNodes[] = $childNode; } else { $leafNodes[] = $childNode; } } } $intermediateNodes = $newIntermediateNodes; } foreach ($leafNodes as $leafNode) { $destinationsCount = count($leafNode->Names->items)/2; for ($count = 0; $count < $destinationsCount; $count++) { $this->_items[$leafNode->Names->items[$count*2]->value] = $leafNode->Names->items[$count*2 + 1]; } } } public function current() { return current($this->_items); } public function next() { return next($this->_items); } public function key() { return key($this->_items); } public function valid() { return current($this->_items)!==false; } public function rewind() { reset($this->_items); } public function offsetExists($offset) { return array_key_exists($offset, $this->_items); } public function offsetGet($offset) { return $this->_items[$offset]; } public function offsetSet($offset, $value) { if ($offset === null) { $this->_items[] = $value; } else { $this->_items[$offset] = $value; } } public function offsetUnset($offset) { unset($this->_items[$offset]); } public function clear() { $this->_items = array(); } public function count() { return count($this->_items); } }

/* @source /library/Zend/Pdf/Parser.php */
class Zend_Pdf_Parser { private $_stringParser; private $_trailer; private $_pdfVersion; public function getPDFLength() { return strlen($this->_stringParser->data); } public function getPDFString() { return $this->_stringParser->data; } public function getPDFVersion() { return $this->_pdfVersion; } private function _loadXRefTable($offset) { $this->_stringParser->offset = $offset; $refTable = new Zend_Pdf_Element_Reference_Table(); $context = new Zend_Pdf_Element_Reference_Context($this->_stringParser, $refTable); $this->_stringParser->setContext($context); $nextLexeme = $this->_stringParser->readLexeme(); if ($nextLexeme == 'xref') { $this->_stringParser->skipWhiteSpace(); while ( ($nextLexeme = $this->_stringParser->readLexeme()) != 'trailer' ) { if (!ctype_digit($nextLexeme)) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Cross-reference table subheader values must contain only digits.', $this->_stringParser->offset-strlen($nextLexeme))); } $objNum = (int)$nextLexeme; $refCount = $this->_stringParser->readLexeme(); if (!ctype_digit($refCount)) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Cross-reference table subheader values must contain only digits.', $this->_stringParser->offset-strlen($refCount))); } $this->_stringParser->skipWhiteSpace(); while ($refCount > 0) { $objectOffset = substr($this->_stringParser->data, $this->_stringParser->offset, 10); if (!ctype_digit($objectOffset)) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Offset must contain only digits.', $this->_stringParser->offset)); } for ($numStart = 0; $numStart < strlen($objectOffset)-1; $numStart++) { if ($objectOffset[$numStart] != '0') { break; } } $objectOffset = substr($objectOffset, $numStart); $this->_stringParser->offset += 10; if (strpos("\x00\t\n\f\r ", $this->_stringParser->data[$this->_stringParser->offset]) === false) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Value separator must be white space.', $this->_stringParser->offset)); } $this->_stringParser->offset++; $genNumber = substr($this->_stringParser->data, $this->_stringParser->offset, 5); if (!ctype_digit($objectOffset)) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Offset must contain only digits.', $this->_stringParser->offset)); } for ($numStart = 0; $numStart < strlen($genNumber)-1; $numStart++) { if ($genNumber[$numStart] != '0') { break; } } $genNumber = substr($genNumber, $numStart); $this->_stringParser->offset += 5; if (strpos("\x00\t\n\f\r ", $this->_stringParser->data[$this->_stringParser->offset]) === false) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Value separator must be white space.', $this->_stringParser->offset)); } $this->_stringParser->offset++; $inUseKey = $this->_stringParser->data[$this->_stringParser->offset]; $this->_stringParser->offset++; switch ($inUseKey) { case 'f': unset( $this->_refTable[$objNum . ' ' . $genNumber . ' R'] ); $refTable->addReference($objNum . ' ' . $genNumber . ' R', $objectOffset, false); break; case 'n': $refTable->addReference($objNum . ' ' . $genNumber . ' R', $objectOffset, true); } if ( !Zend_Pdf_StringParser::isWhiteSpace(ord( $this->_stringParser->data[$this->_stringParser->offset] )) ) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Value separator must be white space.', $this->_stringParser->offset)); } $this->_stringParser->offset++; if ( !Zend_Pdf_StringParser::isWhiteSpace(ord( $this->_stringParser->data[$this->_stringParser->offset] )) ) { throw new Zend_Pdf_Exception(sprintf('PDF file cross-reference table syntax error. Offset - 0x%X. Value separator must be white space.', $this->_stringParser->offset)); } $this->_stringParser->offset++; $refCount--; $objNum++; } } $trailerDictOffset = $this->_stringParser->offset; $trailerDict = $this->_stringParser->readElement(); if (!$trailerDict instanceof Zend_Pdf_Element_Dictionary) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X.  Dictionary expected after \'trailer\' keyword.', $trailerDictOffset)); } } else { $xrefStream = $this->_stringParser->getObject($offset, $context); if (!$xrefStream instanceof Zend_Pdf_Element_Object_Stream) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X.  Cross-reference stream expected.', $offset)); } $trailerDict = $xrefStream->dictionary; if ($trailerDict->Type->value != 'XRef') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X.  Cross-reference stream object must have /Type property assigned to /XRef.', $offset)); } if ($trailerDict->W === null || $trailerDict->W->getType() != Zend_Pdf_Element::TYPE_ARRAY) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Cross reference stream dictionary doesn\'t have W entry or it\'s not an array.', $offset)); } $entryField1Size = $trailerDict->W->items[0]->value; $entryField2Size = $trailerDict->W->items[1]->value; $entryField3Size = $trailerDict->W->items[2]->value; if ($entryField2Size == 0 || $entryField3Size == 0) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Wrong W dictionary entry. Only type field of stream entries has default value and could be zero length.', $offset)); } $xrefStreamData = $xrefStream->value; if ($trailerDict->Index !== null) { if ($trailerDict->Index->getType() != Zend_Pdf_Element::TYPE_ARRAY) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Cross reference stream dictionary Index entry must be an array.', $offset)); } $sections = count($trailerDict->Index->items)/2; } else { $sections = 1; } $streamOffset = 0; $size = $entryField1Size + $entryField2Size + $entryField3Size; $entries = strlen($xrefStreamData)/$size; for ($count = 0; $count < $sections; $count++) { if ($trailerDict->Index !== null) { $objNum = $trailerDict->Index->items[$count*2 ]->value; $entries = $trailerDict->Index->items[$count*2 + 1]->value; } else { $objNum = 0; $entries = $trailerDict->Size->value; } for ($count2 = 0; $count2 < $entries; $count2++) { if ($entryField1Size == 0) { $type = 1; } else if ($entryField1Size == 1) { $type = ord($xrefStreamData[$streamOffset++]); } else { $type = Zend_Pdf_StringParser::parseIntFromStream($xrefStreamData, $streamOffset, $entryField1Size); $streamOffset += $entryField1Size; } if ($entryField2Size == 1) { $field2 = ord($xrefStreamData[$streamOffset++]); } else { $field2 = Zend_Pdf_StringParser::parseIntFromStream($xrefStreamData, $streamOffset, $entryField2Size); $streamOffset += $entryField2Size; } if ($entryField3Size == 1) { $field3 = ord($xrefStreamData[$streamOffset++]); } else { $field3 = Zend_Pdf_StringParser::parseIntFromStream($xrefStreamData, $streamOffset, $entryField3Size); $streamOffset += $entryField3Size; } switch ($type) { case 0: $refTable->addReference($objNum . ' ' . $field3 . ' R', $field2, false); break; case 1: $refTable->addReference($objNum . ' ' . $field3 . ' R', $field2, true); break; case 2: break; } $objNum++; } } throw new Zend_Pdf_Exception('Cross-reference streams are not supported yet.'); } $trailerObj = new Zend_Pdf_Trailer_Keeper($trailerDict, $context); if ($trailerDict->Prev instanceof Zend_Pdf_Element_Numeric || $trailerDict->Prev instanceof Zend_Pdf_Element_Reference ) { $trailerObj->setPrev($this->_loadXRefTable($trailerDict->Prev->value)); $context->getRefTable()->setParent($trailerObj->getPrev()->getRefTable()); } $trailerObj->Prev = new Zend_Pdf_Element_Numeric($offset); return $trailerObj; } public function getTrailer() { return $this->_trailer; } public function __construct($source, Zend_Pdf_ElementFactory_Interface $factory, $load) { if ($load) { if (($pdfFile = @fopen($source, 'rb')) === false ) { throw new Zend_Pdf_Exception( "Can not open '$source' file for reading." ); } $data = ''; $byteCount = filesize($source); while ($byteCount > 0 && !feof($pdfFile)) { $nextBlock = fread($pdfFile, $byteCount); if ($nextBlock === false) { throw new Zend_Pdf_Exception( "Error occured while '$source' file reading." ); } $data .= $nextBlock; $byteCount -= strlen($nextBlock); } if ($byteCount != 0) { throw new Zend_Pdf_Exception( "Error occured while '$source' file reading." ); } fclose($pdfFile); $this->_stringParser = new Zend_Pdf_StringParser($data, $factory); } else { $this->_stringParser = new Zend_Pdf_StringParser($source, $factory); } $pdfVersionComment = $this->_stringParser->readComment(); if (substr($pdfVersionComment, 0, 5) != '%PDF-') { throw new Zend_Pdf_Exception('File is not a PDF.'); } $pdfVersion = substr($pdfVersionComment, 5); if (version_compare($pdfVersion, '0.9', '<') || version_compare($pdfVersion, '1.61', '>=') ) { throw new Zend_Pdf_Exception(sprintf('Unsupported PDF version. Zend_Pdf supports PDF 1.0-1.4. Current version - \'%f\'', $pdfVersion)); } $this->_pdfVersion = $pdfVersion; $this->_stringParser->offset = strrpos($this->_stringParser->data, '%%EOF'); if ($this->_stringParser->offset === false || strlen($this->_stringParser->data) - $this->_stringParser->offset > 7) { throw new Zend_Pdf_Exception('Pdf file syntax error. End-of-fle marker expected at the end of file.'); } $this->_stringParser->offset--; while (Zend_Pdf_StringParser::isWhiteSpace( ord($this->_stringParser->data[$this->_stringParser->offset]) )&& ($this->_stringParser->offset > 0)) { $this->_stringParser->offset--; } while ( (!Zend_Pdf_StringParser::isWhiteSpace( ord($this->_stringParser->data[$this->_stringParser->offset]) ))&& ($this->_stringParser->offset > 0)) { $this->_stringParser->offset--; } while (Zend_Pdf_StringParser::isWhiteSpace( ord($this->_stringParser->data[$this->_stringParser->offset]) )&& ($this->_stringParser->offset > 0)) { $this->_stringParser->offset--; } $this->_stringParser->offset -= 9; $nextLexeme = $this->_stringParser->readLexeme(); if ($nextLexeme != 'startxref') { throw new Zend_Pdf_Exception(sprintf('Pdf file syntax error. \'startxref\' keyword expected. Offset - 0x%X.', $this->_stringParser->offset-strlen($nextLexeme))); } $startXref = $this->_stringParser->readLexeme(); if (!ctype_digit($startXref)) { throw new Zend_Pdf_Exception(sprintf('Pdf file syntax error. Cross-reference table offset must contain only digits. Offset - 0x%X.', $this->_stringParser->offset-strlen($nextLexeme))); } $this->_trailer = $this->_loadXRefTable($startXref); $factory->setObjectCount($this->_trailer->Size->value); } public function __destruct() { $this->_stringParser->cleanUp(); } }

/* @source /library/Zend/Pdf/StringParser.php */
class Zend_Pdf_StringParser { public $data = ''; public $offset = 0; private $_context = null; private $_elements = array(); private $_objFactory = null; public function cleanUp() { $this->_context = null; $this->_elements = array(); $this->_objFactory = null; } public static function isWhiteSpace($chCode) { if ($chCode == 0x00 || $chCode == 0x09 || $chCode == 0x0A || $chCode == 0x0C || $chCode == 0x0D || $chCode == 0x20 ) { return true; } else { return false; } } public static function isDelimiter($chCode ) { if ($chCode == 0x28 || $chCode == 0x29 || $chCode == 0x3C || $chCode == 0x3E || $chCode == 0x5B || $chCode == 0x5D || $chCode == 0x7B || $chCode == 0x7D || $chCode == 0x2F || $chCode == 0x25 ) { return true; } else { return false; } } public function skipWhiteSpace($skipComment = true) { if ($skipComment) { while (true) { $this->offset += strspn($this->data, "\x00\t\n\f\r ", $this->offset); if ($this->offset < strlen($this->data) && $this->data[$this->offset] == '%') { $this->offset += strcspn($this->data, "\r\n", $this->offset); } else { return; } } } else { $this->offset += strspn($this->data, "\x00\t\n\f\r ", $this->offset); } } public function skipComment() { while ($this->offset < strlen($this->data)) { if (ord($this->data[$this->offset]) != 0x0A || ord($this->data[$this->offset]) != 0x0d ) { $this->offset++; } else { return; } } } public function readComment() { $this->skipWhiteSpace(false); if ($this->data[$this->offset] != '%') { return ''; } for ($start = $this->offset; $this->offset < strlen($this->data); $this->offset++) { if (ord($this->data[$this->offset]) == 0x0A || ord($this->data[$this->offset]) == 0x0d ) { break; } } return substr($this->data, $start, $this->offset-$start); } public function readLexeme() { while (true) { $this->offset += strspn($this->data, "\x00\t\n\f\r ", $this->offset); if ($this->offset < strlen($this->data) && $this->data[$this->offset] == '%') { $this->offset += strcspn($this->data, "\r\n", $this->offset); } else { break; } } if ($this->offset >= strlen($this->data)) { return ''; } if ( strpos('()<>[]{}/%', $this->data[$this->offset]) !== false ) { switch (substr($this->data, $this->offset, 2)) { case '<<': $this->offset += 2; return '<<'; break; case '>>': $this->offset += 2; return '>>'; break; default: return $this->data[$this->offset++]; break; } } else { $start = $this->offset; $compare = ''; if( version_compare( phpversion(), '5.2.5' ) >= 0) { $compare = "()<>[]{}/%\x00\t\n\f\r "; } else { $compare = "()<>[]{}/%\x00\t\n\r "; } $this->offset += strcspn($this->data, $compare, $this->offset); return substr($this->data, $start, $this->offset - $start); } } public function readElement($nextLexeme = null) { if ($nextLexeme === null) { $nextLexeme = $this->readLexeme(); } switch ($nextLexeme) { case '(': return ($this->_elements[] = $this->_readString()); case '<': return ($this->_elements[] = $this->_readBinaryString()); case '/': return ($this->_elements[] = new Zend_Pdf_Element_Name( Zend_Pdf_Element_Name::unescape( $this->readLexeme() ) )); case '[': return ($this->_elements[] = $this->_readArray()); case '<<': return ($this->_elements[] = $this->_readDictionary()); case ')': case '>': case ']': case '>>': case '{': case '}': throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X.', $this->offset)); default: if (strcasecmp($nextLexeme, 'true') == 0) { return ($this->_elements[] = new Zend_Pdf_Element_Boolean(true)); } else if (strcasecmp($nextLexeme, 'false') == 0) { return ($this->_elements[] = new Zend_Pdf_Element_Boolean(false)); } else if (strcasecmp($nextLexeme, 'null') == 0) { return ($this->_elements[] = new Zend_Pdf_Element_Null()); } $ref = $this->_readReference($nextLexeme); if ($ref !== null) { return ($this->_elements[] = $ref); } return ($this->_elements[] = $this->_readNumeric($nextLexeme)); } } private function _readString() { $start = $this->offset; $openedBrackets = 1; $this->offset += strcspn($this->data, '()\\', $this->offset); while ($this->offset < strlen($this->data)) { switch (ord( $this->data[$this->offset] )) { case 0x28: $this->offset++; $openedBrackets++; break; case 0x29: $this->offset++; $openedBrackets--; break; case 0x5C: $this->offset += 2; } if ($openedBrackets == 0) { break; } $this->offset += strcspn($this->data, '()\\', $this->offset); } if ($openedBrackets != 0) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Unexpected end of file while string reading. Offset - 0x%X. \')\' expected.', $start)); } return new Zend_Pdf_Element_String(Zend_Pdf_Element_String::unescape( substr($this->data, $start, $this->offset - $start - 1) )); } private function _readBinaryString() { $start = $this->offset; $this->offset += strspn($this->data, "\x00\t\n\f\r 0123456789abcdefABCDEF", $this->offset); if ($this->offset >= strlen($this->data) - 1) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Unexpected end of file while reading binary string. Offset - 0x%X. \'>\' expected.', $start)); } if ($this->data[$this->offset++] != '>') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Unexpected character while binary string reading. Offset - 0x%X.', $this->offset)); } return new Zend_Pdf_Element_String_Binary( Zend_Pdf_Element_String_Binary::unescape( substr($this->data, $start, $this->offset - $start - 1) )); } private function _readArray() { $elements = array(); while ( strlen($nextLexeme = $this->readLexeme()) != 0 ) { if ($nextLexeme != ']') { $elements[] = $this->readElement($nextLexeme); } else { return new Zend_Pdf_Element_Array($elements); } } throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Unexpected end of file while array reading. Offset - 0x%X. \']\' expected.', $this->offset)); } private function _readDictionary() { $dictionary = new Zend_Pdf_Element_Dictionary(); while ( strlen($nextLexeme = $this->readLexeme()) != 0 ) { if ($nextLexeme != '>>') { $nameStart = $this->offset - strlen($nextLexeme); $name = $this->readElement($nextLexeme); $value = $this->readElement(); if (!$name instanceof Zend_Pdf_Element_Name) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Name object expected while dictionary reading. Offset - 0x%X.', $nameStart)); } $dictionary->add($name, $value); } else { return $dictionary; } } throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Unexpected end of file while dictionary reading. Offset - 0x%X. \'>>\' expected.', $this->offset)); } private function _readReference($nextLexeme = null) { $start = $this->offset; if ($nextLexeme === null) { $objNum = $this->readLexeme(); } else { $objNum = $nextLexeme; } if (!ctype_digit($objNum)) { $this->offset = $start; return null; } $genNum = $this->readLexeme(); if (!ctype_digit($genNum)) { $this->offset = $start; return null; } $rMark = $this->readLexeme(); if ($rMark != 'R') { $this->offset = $start; return null; } $ref = new Zend_Pdf_Element_Reference((int)$objNum, (int)$genNum, $this->_context, $this->_objFactory->resolve()); return $ref; } private function _readNumeric($nextLexeme = null) { if ($nextLexeme === null) { $nextLexeme = $this->readLexeme(); } return new Zend_Pdf_Element_Numeric($nextLexeme); } public function getObject($offset, Zend_Pdf_Element_Reference_Context $context) { if ($offset === null ) { return new Zend_Pdf_Element_Null(); } $offsetSave = $this->offset; $this->offset = $offset; $this->_context = $context; $this->_elements = array(); $objNum = $this->readLexeme(); if (!ctype_digit($objNum)) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Object number expected.', $this->offset - strlen($objNum))); } $genNum = $this->readLexeme(); if (!ctype_digit($genNum)) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Object generation number expected.', $this->offset - strlen($genNum))); } $objKeyword = $this->readLexeme(); if ($objKeyword != 'obj') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. \'obj\' keyword expected.', $this->offset - strlen($objKeyword))); } $objValue = $this->readElement(); $nextLexeme = $this->readLexeme(); if( $nextLexeme == 'endobj' ) { $obj = new Zend_Pdf_Element_Object($objValue, (int)$objNum, (int)$genNum, $this->_objFactory->resolve()); foreach ($this->_elements as $element) { $element->setParentObject($obj); } $this->offset = $offsetSave; return $obj; } if ($nextLexeme != 'stream') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. \'endobj\' or \'stream\' keywords expected.', $this->offset - strlen($nextLexeme))); } if (!$objValue instanceof Zend_Pdf_Element_Dictionary) { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. Stream extent must be preceded by stream dictionary.', $this->offset - strlen($nextLexeme))); } $streamLength = $objValue->Length->value; if ($this->data[$this->offset] == "\r" && $this->data[$this->offset + 1] == "\n" ) { $this->offset += 2; } else if ($this->data[$this->offset] == "\n" ) { $this->offset++; } else { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. \'stream\' must be followed by either cr-lf sequence or lf character only.', $this->offset - strlen($nextLexeme))); } $dataOffset = $this->offset; $this->offset += $streamLength; $nextLexeme = $this->readLexeme(); if ($nextLexeme != 'endstream') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. \'endstream\' keyword expected.', $this->offset - strlen($nextLexeme))); } $nextLexeme = $this->readLexeme(); if ($nextLexeme != 'endobj') { throw new Zend_Pdf_Exception(sprintf('PDF file syntax error. Offset - 0x%X. \'endobj\' keyword expected.', $this->offset - strlen($nextLexeme))); } $obj = new Zend_Pdf_Element_Object_Stream(substr($this->data, $dataOffset, $streamLength), (int)$objNum, (int)$genNum, $this->_objFactory->resolve(), $objValue); foreach ($this->_elements as $element) { $element->setParentObject($obj); } $this->offset = $offsetSave; return $obj; } public function getLength() { return strlen($this->data); } public function getString() { return $this->data; } public static function parseIntFromStream($stream, $offset, $size) { $value = 0; for ($count = 0; $count < $size; $count++) { $value *= 256; $value += ord($stream[$offset + $count]); } return $value; } public function setContext(Zend_Pdf_Element_Reference_Context $context) { $this->_context = $context; } public function __construct($source, Zend_Pdf_ElementFactory_Interface $factory) { $this->data = $source; $this->_objFactory = $factory; } }

/* @source /library/Zend/Pdf/Style.php */
class Zend_Pdf_Style { private $_fillColor = null; private $_color; private $_lineWidth; private $_lineDashingPattern; private $_lineDashingPhase; private $_font; private $_fontSize; public function __construct($anotherStyle = null) { if ($anotherStyle !== null) { $this->_fillColor = $anotherStyle->_fillColor; $this->_color = $anotherStyle->_color; $this->_lineWidth = $anotherStyle->_lineWidth; $this->_lineDashingPattern = $anotherStyle->_lineDashingPattern; $this->_lineDashingPhase = $anotherStyle->_lineDashingPhase; $this->_font = $anotherStyle->_font; $this->_fontSize = $anotherStyle->_fontSize; } } public function setFillColor(Zend_Pdf_Color $color) { $this->_fillColor = $color; } public function setLineColor(Zend_Pdf_Color $color) { $this->_color = $color; } public function setLineWidth($width) { $this->_lineWidth = new Zend_Pdf_Element_Numeric($width); } public function setLineDashingPattern($pattern, $phase = 0) { if ($pattern === Zend_Pdf_Page::LINE_DASHING_SOLID) { $pattern = array(); $phase = 0; } $this->_lineDashingPattern = $pattern; $this->_lineDashingPhase = new Zend_Pdf_Element_Numeric($phase); } public function setFont(Zend_Pdf_Resource_Font $font, $fontSize) { $this->_font = $font; $this->_fontSize = $fontSize; } public function setFontSize($fontSize) { $this->_fontSize = $fontSize; } public function getFillColor() { return $this->_fillColor; } public function getLineColor() { return $this->_color; } public function getLineWidth() { return $this->_lineWidth->value; } public function getLineDashingPattern() { return $this->_lineDashingPattern; } public function getFont() { return $this->_font; } public function getFontSize() { return $this->_fontSize; } public function getLineDashingPhase() { return $this->_lineDashingPhase->value; } public function instructions() { $instructions = ''; if ($this->_fillColor !== null) { $instructions .= $this->_fillColor->instructions(false); } if ($this->_color !== null) { $instructions .= $this->_color->instructions(true); } if ($this->_lineWidth !== null) { $instructions .= $this->_lineWidth->toString() . " w\n"; } if ($this->_lineDashingPattern !== null) { $dashPattern = new Zend_Pdf_Element_Array(); foreach ($this->_lineDashingPattern as $dashItem) { $dashElement = new Zend_Pdf_Element_Numeric($dashItem); $dashPattern->items[] = $dashElement; } $instructions .= $dashPattern->toString() . ' ' . $this->_lineDashingPhase->toString() . " d\n"; } return $instructions; } }

/* @source /library/Zend/Pdf/Resource/GraphicsState.php */
class Zend_Pdf_Resource_GraphicsState extends Zend_Pdf_Resource { public function __construct(Zend_Pdf_Element_Object $extGStateObject = null) { if ($extGStateObject == null) { $factory = Zend_Pdf_ElementFactory::createFactory(1); $gsDictionary = new Zend_Pdf_Element_Dictionary(); $gsDictionary->Type = new Zend_Pdf_Element_Name('ExtGState'); $extGStateObject = $factory->newObject($gsDictionary); } if ($extGStateObject->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Graphics state PDF object must be a dictionary'); } parent::__construct($gsDictionary); } public function setAlpha($alpha, $mode = 'Normal') { if (!in_array($mode, array('Normal', 'Multiply', 'Screen', 'Overlay', 'Darken', 'Lighten', 'ColorDodge', 'ColorBurn', 'HardLight', 'SoftLight', 'Difference', 'Exclusion'))) { throw new Zend_Pdf_Exception('Unsupported transparency mode.'); } if (!is_numeric($alpha) || $alpha < 0 || $alpha > 1) { throw new Zend_Pdf_Exception('Alpha value must be numeric between 0 (transparent) and 1 (opaque).'); } $this->_resource->BM = new Zend_Pdf_Element_Name($mode); $this->_resource->CA = new Zend_Pdf_Element_Numeric($alpha); $this->_resource->ca = new Zend_Pdf_Element_Numeric($alpha); } }

/* @source /library/Zend/Pdf/Resource/ImageFactory.php */
class Zend_Pdf_Resource_ImageFactory { public static function factory($filename) { if(!is_file($filename)) { throw new Zend_Pdf_Exception("Cannot create image resource. File not found."); } $extension = pathinfo($filename, PATHINFO_EXTENSION); switch (strtolower($extension)) { case 'tif': case 'tiff': return new Zend_Pdf_Resource_Image_Tiff($filename); break; case 'png': return new Zend_Pdf_Resource_Image_Png($filename); break; case 'jpg': case 'jpe': case 'jpeg': return new Zend_Pdf_Resource_Image_Jpeg($filename); break; default: throw new Zend_Pdf_Exception("Cannot create image resource. File extension not known or unsupported type."); break; } } }

/* @source /library/Zend/Pdf/ElementFactory/Proxy.php */
class Zend_Pdf_ElementFactory_Proxy implements Zend_Pdf_ElementFactory_Interface { private $_factory; public function __construct(Zend_Pdf_ElementFactory_Interface $factory) { $this->_factory = $factory; } public function __destruct() { $this->_factory->close(); $this->_factory = null; } public function getFactory() { return $this->_factory->getFactory(); } public function close() { } public function resolve() { return $this->_factory->resolve(); } public function getId() { return $this->_factory->getId(); } public function setObjectCount($objCount) { $this->_factory->setObjectCount($objCount); } public function getObjectCount() { return $this->_factory->getObjectCount(); } public function attach(Zend_Pdf_ElementFactory_Interface $factory) { $this->_factory->attach($factory); } public function calculateShift(Zend_Pdf_ElementFactory_Interface $factory) { return $this->_factory->calculateShift($factory); } public function cleanEnumerationShiftCache() { return $this->_factory->cleanEnumerationShiftCache(); } public function getEnumerationShift(Zend_Pdf_ElementFactory_Interface $factory) { return $this->_factory->getEnumerationShift($factory); } public function markAsModified(Zend_Pdf_Element_Object $obj) { $this->_factory->markAsModified($obj); } public function remove(Zend_Pdf_Element_Object $obj) { $this->_factory->remove($obj); } public function newObject(Zend_Pdf_Element $objectValue) { return $this->_factory->newObject($objectValue); } public function newStreamObject($streamValue) { return $this->_factory->newStreamObject($streamValue); } public function listModifiedObjects($rootFactory = null) { return $this->_factory->listModifiedObjects($rootFactory); } public function isModified() { return $this->_factory->isModified(); } }

/* @source /library/Zend/Pdf/Resource/Unified.php */
class Zend_Pdf_Resource_Unified extends Zend_Pdf_Resource { }

/* @source /library/Zend/Pdf/Trailer/Keeper.php */
class Zend_Pdf_Trailer_Keeper extends Zend_Pdf_Trailer { private $_context; private $_prev; public function __construct(Zend_Pdf_Element_Dictionary $dict, Zend_Pdf_Element_Reference_Context $context, Zend_Pdf_Trailer $prev = null) { parent::__construct($dict); $this->_context = $context; $this->_prev = $prev; } public function setPrev(Zend_Pdf_Trailer_Keeper $prev) { $this->_prev = $prev; } public function getPrev() { return $this->_prev; } public function getPDFLength() { return $this->_context->getParser()->getLength(); } public function getPDFString() { return $this->_context->getParser()->getString(); } public function getRefTable() { return $this->_context->getRefTable(); } public function getLastFreeObject() { try { $this->_context->getRefTable()->getNextFree('0 65535 R'); } catch (Zend_Pdf_Exception $e) { if ($e->getMessage() == 'Object not found.') { return 0; } throw new Zend_Pdf_Exception($e->getMessage(), $e->getCode(), $e); } } }

/* @source /library/Zend/Pdf/Resource/ContentStream.php */
class Zend_Pdf_Resource_ContentStream extends Zend_Pdf_Resource { protected $_bufferedContent = ''; public function __construct($contentStreamObject = '') { if ($contentStreamObject !== null && !$contentStreamObject instanceof Zend_Pdf_Element_Object_Stream && !is_string($contentStreamObject) ) { throw new Zend_Pdf_Exception('Content stream parameter must be a string or stream object'); } parent::__construct($contentStreamObject); } public function addInstructions($instructions) { $this->_bufferedContent .= $instructions; return $this; } public function getInstructions() { $this->flush(); return $this->_resource->value; } public function clear() { $this->_resource->value = ''; $this->_bufferedContent = ''; return $this; } public function flush() { $this->_resource->value .= $this->_bufferedContent; $this->_bufferedContent = ''; return $this; } }

/* @source /library/Zend/Pdf/Action/Unknown.php */
class Zend_Pdf_Action_Unknown extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Launch.php */
class Zend_Pdf_Action_Launch extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Named.php */
class Zend_Pdf_Action_Named extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Trans.php */
class Zend_Pdf_Action_Trans extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/GoToR.php */
class Zend_Pdf_Action_GoToR extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Sound.php */
class Zend_Pdf_Action_Sound extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Rendition.php */
class Zend_Pdf_Action_Rendition extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/GoToE.php */
class Zend_Pdf_Action_GoToE extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/ResetForm.php */
class Zend_Pdf_Action_ResetForm extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/SubmitForm.php */
class Zend_Pdf_Action_SubmitForm extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/ImportData.php */
class Zend_Pdf_Action_ImportData extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Hide.php */
class Zend_Pdf_Action_Hide extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/URI.php */
class Zend_Pdf_Action_URI extends Zend_Pdf_Action { public function __construct(Zend_Pdf_Element $dictionary, SplObjectStorage $processedActions) { parent::__construct($dictionary, $processedActions); if ($dictionary->URI === null) { throw new Zend_Pdf_Exception('URI action dictionary entry is required'); } } protected static function _validateUri($uri) { $scheme = parse_url((string)$uri, PHP_URL_SCHEME); if ($scheme === false || $scheme === null) { throw new Zend_Pdf_Exception('Invalid URI'); } } public static function create($uri, $isMap = false) { self::_validateUri($uri); $dictionary = new Zend_Pdf_Element_Dictionary(); $dictionary->Type = new Zend_Pdf_Element_Name('Action'); $dictionary->S = new Zend_Pdf_Element_Name('URI'); $dictionary->Next = null; $dictionary->URI = new Zend_Pdf_Element_String($uri); if ($isMap) { $dictionary->IsMap = new Zend_Pdf_Element_Boolean(true); } return new Zend_Pdf_Action_URI($dictionary, new SplObjectStorage()); } public function setUri($uri) { $this->_validateUri($uri); $this->_actionDictionary->touch(); $this->_actionDictionary->URI = new Zend_Pdf_Element_String($uri); return $this; } public function getUri() { return $this->_actionDictionary->URI->value; } public function setIsMap($isMap) { $this->_actionDictionary->touch(); if ($isMap) { $this->_actionDictionary->IsMap = new Zend_Pdf_Element_Boolean(true); } else { $this->_actionDictionary->IsMap = null; } return $this; } public function getIsMap() { return $this->_actionDictionary->IsMap !== null && $this->_actionDictionary->IsMap->value; } }

/* @source /library/Zend/Pdf/Resource/Extractor.php */
class Zend_Pdf_Resource_Extractor { protected $_factory; protected $_processed; public function __construct() { $this->_factory = Zend_Pdf_ElementFactory::createFactory(1); $this->_processed = array(); } public function clonePage(Zend_Pdf_Page $page) { return $page->clonePage($this->_factory, $this->_processed); } }

/* @source /library/Zend/Pdf/Action/GoTo3DView.php */
class Zend_Pdf_Action_GoTo3DView extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Thread.php */
class Zend_Pdf_Action_Thread extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Cmap/SegmentToDelta.php */
class Zend_Pdf_Cmap_SegmentToDelta extends Zend_Pdf_Cmap { protected $_segmentCount = 0; protected $_searchRange = 0; protected $_searchIterations = 0; protected $_segmentTableEndCodes = array(); protected $_searchRangeEndCode = 0; protected $_segmentTableStartCodes = array(); protected $_segmentTableIdDeltas = array(); protected $_segmentTableIdRangeOffsets = array(); protected $_glyphIndexArray = array(); public function glyphNumbersForCharacters($characterCodes) { $glyphNumbers = array(); foreach ($characterCodes as $key => $characterCode) { if ($characterCode > 0xffff) { $glyphNumbers[$key] = Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; continue; } if ($this->_searchRangeEndCode >= $characterCode) { $searchIndex = $this->_searchRange; } else { $searchIndex = $this->_segmentCount; } for ($i = 1; $i <= $this->_searchIterations; $i++) { if ($this->_segmentTableEndCodes[$searchIndex] >= $characterCode) { $subtableIndex = $searchIndex; $searchIndex -= $this->_searchRange >> $i; } else { $searchIndex += $this->_searchRange >> $i; } } if ($this->_segmentTableStartCodes[$subtableIndex] > $characterCode) { $glyphNumbers[$key] = Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; continue; } if ($this->_segmentTableIdRangeOffsets[$subtableIndex] == 0) { $glyphNumbers[$key] = ($characterCode + $this->_segmentTableIdDeltas[$subtableIndex]) % 65536; } else { $glyphIndex = ($characterCode - $this->_segmentTableStartCodes[$subtableIndex] + $this->_segmentTableIdRangeOffsets[$subtableIndex] - $this->_segmentCount + $subtableIndex - 1); $glyphNumbers[$key] = $this->_glyphIndexArray[$glyphIndex]; } } return $glyphNumbers; } public function glyphNumberForCharacter($characterCode) { if ($characterCode > 0xffff) { return Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; } if ($this->_searchRangeEndCode >= $characterCode) { $searchIndex = $this->_searchRange; } else { $searchIndex = $this->_segmentCount; } for ($i = 1; $i <= $this->_searchIterations; $i++) { if ($this->_segmentTableEndCodes[$searchIndex] >= $characterCode) { $subtableIndex = $searchIndex; $searchIndex -= $this->_searchRange >> $i; } else { $searchIndex += $this->_searchRange >> $i; } } if ($this->_segmentTableStartCodes[$subtableIndex] > $characterCode) { return Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; } if ($this->_segmentTableIdRangeOffsets[$subtableIndex] == 0) { $glyphNumber = ($characterCode + $this->_segmentTableIdDeltas[$subtableIndex]) % 65536; } else { $glyphIndex = ($characterCode - $this->_segmentTableStartCodes[$subtableIndex] + $this->_segmentTableIdRangeOffsets[$subtableIndex] - $this->_segmentCount + $subtableIndex - 1); $glyphNumber = $this->_glyphIndexArray[$glyphIndex]; } return $glyphNumber; } public function getCoveredCharacters() { $characterCodes = array(); for ($i = 1; $i <= $this->_segmentCount; $i++) { for ($code = $this->_segmentTableStartCodes[$i]; $code <= $this->_segmentTableEndCodes[$i]; $code++) { $characterCodes[] = $code; } } return $characterCodes; } public function getCoveredCharactersGlyphs() { $glyphNumbers = array(); for ($segmentNum = 1; $segmentNum <= $this->_segmentCount; $segmentNum++) { if ($this->_segmentTableIdRangeOffsets[$segmentNum] == 0) { $delta = $this->_segmentTableIdDeltas[$segmentNum]; for ($code = $this->_segmentTableStartCodes[$segmentNum]; $code <= $this->_segmentTableEndCodes[$segmentNum]; $code++) { $glyphNumbers[$code] = ($code + $delta) % 65536; } } else { $code = $this->_segmentTableStartCodes[$segmentNum]; $glyphIndex = $this->_segmentTableIdRangeOffsets[$segmentNum] - ($this->_segmentCount - $segmentNum) - 1; while ($code <= $this->_segmentTableEndCodes[$segmentNum]) { $glyphNumbers[$code] = $this->_glyphIndexArray[$glyphIndex]; $code++; $glyphIndex++; } } } return $glyphNumbers; } public function __construct($cmapData) { $actualLength = strlen($cmapData); if ($actualLength < 23) { throw new Zend_Pdf_Exception('Insufficient table data', Zend_Pdf_Exception::CMAP_TABLE_DATA_TOO_SMALL); } $type = $this->_extractUInt2($cmapData, 0); if ($type != Zend_Pdf_Cmap::TYPE_SEGMENT_TO_DELTA) { throw new Zend_Pdf_Exception('Wrong cmap table type', Zend_Pdf_Exception::CMAP_WRONG_TABLE_TYPE); } $length = $this->_extractUInt2($cmapData, 2); if ($length != $actualLength) { throw new Zend_Pdf_Exception("Table length ($length) does not match actual length ($actualLength)", Zend_Pdf_Exception::CMAP_WRONG_TABLE_LENGTH); } $language = $this->_extractUInt2($cmapData, 4); if ($language != 0) { } $this->_segmentCount = $this->_extractUInt2($cmapData, 6) >> 1; $this->_searchRange = $this->_extractUInt2($cmapData, 8) >> 1; $this->_searchIterations = $this->_extractUInt2($cmapData, 10) + 1; $offset = 14; for ($i = 1; $i <= $this->_segmentCount; $i++, $offset += 2) { $this->_segmentTableEndCodes[$i] = $this->_extractUInt2($cmapData, $offset); } $this->_searchRangeEndCode = $this->_segmentTableEndCodes[$this->_searchRange]; $offset += 2; for ($i = 1; $i <= $this->_segmentCount; $i++, $offset += 2) { $this->_segmentTableStartCodes[$i] = $this->_extractUInt2($cmapData, $offset); } for ($i = 1; $i <= $this->_segmentCount; $i++, $offset += 2) { $this->_segmentTableIdDeltas[$i] = $this->_extractInt2($cmapData, $offset); } for ($i = 1; $i <= $this->_segmentCount; $i++, $offset += 2) { $this->_segmentTableIdRangeOffsets[$i] = $this->_extractUInt2($cmapData, $offset) >> 1; } for (; $offset < $length; $offset += 2) { $this->_glyphIndexArray[] = $this->_extractUInt2($cmapData, $offset); } if ($offset != $length) { throw new Zend_Pdf_Exception("Ending offset ($offset) does not match length ($length)", Zend_Pdf_Exception::CMAP_FINAL_OFFSET_NOT_LENGTH); } } }

/* @source /library/Zend/Pdf/Cmap/ByteEncoding.php */
class Zend_Pdf_Cmap_ByteEncoding extends Zend_Pdf_Cmap { protected $_glyphIndexArray = array(); public function glyphNumbersForCharacters($characterCodes) { $glyphNumbers = array(); foreach ($characterCodes as $key => $characterCode) { if (! isset($this->_glyphIndexArray[$characterCode])) { $glyphNumbers[$key] = Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; continue; } $glyphNumbers[$key] = $this->_glyphIndexArray[$characterCode]; } return $glyphNumbers; } public function glyphNumberForCharacter($characterCode) { if (! isset($this->_glyphIndexArray[$characterCode])) { return Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; } return $this->_glyphIndexArray[$characterCode]; } public function getCoveredCharacters() { return array_keys($this->_glyphIndexArray); } public function getCoveredCharactersGlyphs() { return $this->_glyphIndexArray; } public function __construct($cmapData) { $actualLength = strlen($cmapData); if ($actualLength != 262) { throw new Zend_Pdf_Exception('Insufficient table data', Zend_Pdf_Exception::CMAP_TABLE_DATA_TOO_SMALL); } $type = $this->_extractUInt2($cmapData, 0); if ($type != Zend_Pdf_Cmap::TYPE_BYTE_ENCODING) { throw new Zend_Pdf_Exception('Wrong cmap table type', Zend_Pdf_Exception::CMAP_WRONG_TABLE_TYPE); } $length = $this->_extractUInt2($cmapData, 2); if ($length != $actualLength) { throw new Zend_Pdf_Exception("Table length ($length) does not match actual length ($actualLength)", Zend_Pdf_Exception::CMAP_WRONG_TABLE_LENGTH); } $language = $this->_extractUInt2($cmapData, 4); if ($language != 0) { } $i = 6; $this->_glyphIndexArray[0x00] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x01] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x03] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x04] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x05] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x06] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x07] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x08] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x09] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x10] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x11] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x12] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x13] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x14] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x15] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x16] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x17] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x18] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x19] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x1f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x20] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x21] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x22] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x23] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x24] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x25] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x26] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x27] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x28] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x29] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x30] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x31] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x32] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x33] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x34] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x35] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x36] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x37] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x38] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x39] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x3f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x40] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x41] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x42] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x43] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x44] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x45] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x46] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x47] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x48] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x49] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x4f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x50] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x51] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x52] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x53] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x54] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x55] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x56] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x57] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x58] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x59] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x5f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x60] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x61] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x62] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x63] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x64] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x65] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x66] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x67] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x68] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x69] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x6f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x70] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x71] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x72] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x73] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x74] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x75] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x76] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x77] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x78] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x79] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x7f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc4] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc7] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xdc] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe0] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe2] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe4] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe3] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe7] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xea] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xeb] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xed] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xec] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xee] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xef] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf3] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf2] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf4] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xfa] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xfb] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xfc] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2020] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb0] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa2] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa3] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa7] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2022] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xdf] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xae] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2122] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb4] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2260] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x221e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2264] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2265] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2202] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2211] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x220f] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x03c0] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x222b] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xaa] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xba] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x03a9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xe6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xbf] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xac] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x221a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0192] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2248] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2206] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xab] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xbb] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2026] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xa0] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc0] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc3] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd5] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0152] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0153] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2013] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2014] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x201c] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x201d] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2018] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2019] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf7] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x25ca] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xff] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0178] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2044] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x20ac] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2039] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x203a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xfb01] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xfb02] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2021] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb7] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x201a] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x201e] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x2030] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc2] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xca] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc1] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xcb] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xc8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xcd] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xce] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xcf] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xcc] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd3] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd4] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xf8ff] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd2] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xda] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xdb] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xd9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x0131] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02c6] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02dc] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xaf] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02d8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02d9] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02da] = ord($cmapData[$i++]); $this->_glyphIndexArray[0xb8] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02dd] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02db] = ord($cmapData[$i++]); $this->_glyphIndexArray[0x02c7] = ord($cmapData[$i]); } }

/* @source /library/Zend/Pdf/Action/SetOCGState.php */
class Zend_Pdf_Action_SetOCGState extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/Movie.php */
class Zend_Pdf_Action_Movie extends Zend_Pdf_Action { }

/* @source /library/Zend/Pdf/Action/GoTo.php */
class Zend_Pdf_Action_GoTo extends Zend_Pdf_Action { protected $_destination; public function __construct(Zend_Pdf_Element $dictionary, SplObjectStorage $processedActions) { parent::__construct($dictionary, $processedActions); $this->_destination = Zend_Pdf_Destination::load($dictionary->D); } public static function create($destination) { if (is_string($destination)) { $destination = Zend_Pdf_Destination_Named::create($destination); } if (!$destination instanceof Zend_Pdf_Destination) { throw new Zend_Pdf_Exception('$destination parameter must be a Zend_Pdf_Destination object or string.'); } $dictionary = new Zend_Pdf_Element_Dictionary(); $dictionary->Type = new Zend_Pdf_Element_Name('Action'); $dictionary->S = new Zend_Pdf_Element_Name('GoTo'); $dictionary->Next = null; $dictionary->D = $destination->getResource(); return new Zend_Pdf_Action_GoTo($dictionary, new SplObjectStorage()); } public function setDestination(Zend_Pdf_Destination $destination) { $this->_destination = $destination; $this->_actionDictionary->touch(); $this->_actionDictionary->D = $destination->getResource(); return $this; } public function getDestination() { return $this->_destination; } }

/* @source /library/Zend/Pdf/Cmap/TrimmedTable.php */
class Zend_Pdf_Cmap_TrimmedTable extends Zend_Pdf_Cmap { protected $_startCode = 0; protected $_endCode = 0; protected $_glyphIndexArray = array(); public function glyphNumbersForCharacters($characterCodes) { $glyphNumbers = array(); foreach ($characterCodes as $key => $characterCode) { if (($characterCode < $this->_startCode) || ($characterCode > $this->_endCode)) { $glyphNumbers[$key] = Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; continue; } $glyphIndex = $characterCode - $this->_startCode; $glyphNumbers[$key] = $this->_glyphIndexArray[$glyphIndex]; } return $glyphNumbers; } public function glyphNumberForCharacter($characterCode) { if (($characterCode < $this->_startCode) || ($characterCode > $this->_endCode)) { return Zend_Pdf_Cmap::MISSING_CHARACTER_GLYPH; } $glyphIndex = $characterCode - $this->_startCode; return $this->_glyphIndexArray[$glyphIndex]; } public function getCoveredCharacters() { $characterCodes = array(); for ($code = $this->_startCode; $code <= $this->_endCode; $code++) { $characterCodes[] = $code; } return $characterCodes; } public function getCoveredCharactersGlyphs() { $glyphNumbers = array(); for ($code = $this->_startCode; $code <= $this->_endCode; $code++) { $glyphNumbers[$code] = $this->_glyphIndexArray[$code - $this->_startCode]; } return $glyphNumbers; } public function __construct($cmapData) { $actualLength = strlen($cmapData); if ($actualLength < 9) { throw new Zend_Pdf_Exception('Insufficient table data', Zend_Pdf_Exception::CMAP_TABLE_DATA_TOO_SMALL); } $type = $this->_extractUInt2($cmapData, 0); if ($type != Zend_Pdf_Cmap::TYPE_TRIMMED_TABLE) { throw new Zend_Pdf_Exception('Wrong cmap table type', Zend_Pdf_Exception::CMAP_WRONG_TABLE_TYPE); } $length = $this->_extractUInt2($cmapData, 2); if ($length != $actualLength) { throw new Zend_Pdf_Exception("Table length ($length) does not match actual length ($actualLength)", Zend_Pdf_Exception::CMAP_WRONG_TABLE_LENGTH); } $language = $this->_extractUInt2($cmapData, 4); if ($language != 0) { } $this->_startCode = $this->_extractUInt2($cmapData, 6); $entryCount = $this->_extractUInt2($cmapData, 8); $expectedCount = ($length - 10) >> 1; if ($entryCount != $expectedCount) { throw new Zend_Pdf_Exception("Entry count is wrong; expected: $expectedCount; actual: $entryCount", Zend_Pdf_Exception::CMAP_WRONG_ENTRY_COUNT); } $this->_endCode = $this->_startCode + $entryCount - 1; $offset = 10; for ($i = 0; $i < $entryCount; $i++, $offset += 2) { $this->_glyphIndexArray[] = $this->_extractUInt2($cmapData, $offset); } if ($offset != $length) { throw new Zend_Pdf_Exception("Ending offset ($offset) does not match length ($length)", Zend_Pdf_Exception::CMAP_FINAL_OFFSET_NOT_LENGTH); } } }

/* @source /library/Zend/Pdf/Trailer/Generator.php */
class Zend_Pdf_Trailer_Generator extends Zend_Pdf_Trailer { public function __construct(Zend_Pdf_Element_Dictionary $dict) { parent::__construct($dict); } public function getPDFLength() { return strlen(Zend_Pdf::PDF_HEADER); } public function getPDFString() { return Zend_Pdf::PDF_HEADER; } public function getLastFreeObject() { return 0; } }

/* @source /library/Zend/Pdf/Element/String.php */
class Zend_Pdf_Element_String extends Zend_Pdf_Element { public $value; public function __construct($val) { $this->value = (string)$val; } public function getType() { return Zend_Pdf_Element::TYPE_STRING; } public function toString($factory = null) { return '(' . self::escape((string)$this->value) . ')'; } public static function escape($str) { $outEntries = array(); foreach (str_split($str, 128) as $chunk) { $offset = strcspn($chunk, "\n\r\t\x08\x0C()\\"); $chunkOut = substr($chunk, 0, $offset); while ($offset < strlen($chunk)) { $nextCode = ord($chunk[$offset++]); switch ($nextCode) { case 10: $chunkOut .= '\\n'; break; case 13: $chunkOut .= '\\r'; break; case 9: $chunkOut .= '\\t'; break; case 8: $chunkOut .= '\\b'; break; case 12: $chunkOut .= '\\f'; break; case 40: $chunkOut .= '\\('; break; case 41: $chunkOut .= '\\)'; break; case 92: $chunkOut .= '\\\\'; break; default: break; } $start = $offset; $offset += strcspn($chunk, "\n\r\t\x08\x0C()\\", $offset); $chunkOut .= substr($chunk, $start, $offset - $start); } $outEntries[] = $chunkOut; } return implode("\\\n", $outEntries); } public static function unescape($str) { $outEntries = array(); $offset = 0; while ($offset < strlen($str)) { $escapeCharOffset = strpos($str, '\\', $offset); if ($escapeCharOffset === false || $escapeCharOffset == strlen($str) - 1) { $outEntries[] = substr($str, $offset); break; } else { $outEntries[] = substr($str, $offset, $escapeCharOffset - $offset); $offset = $escapeCharOffset + 1; switch ($str[$offset]) { case 'n': $outEntries[] = "\n"; break; case 'r': $outEntries[] = "\r"; break; case 't': $outEntries[] = "\t"; break; case 'b': $outEntries[] = "\x08"; break; case 'f': $outEntries[] = "\x0C"; break; case '(': $outEntries[] = '('; break; case ')': $outEntries[] = ')'; break; case '\\': $outEntries[] = '\\'; break; case "\n": if ($str[$offset + 1] == "\r") { $offset++; } break; default: if (strpos('0123456789', $str[$offset]) !== false) { $nextCode = '0' . $str[$offset]; if (strpos('0123456789', $str[$offset + 1]) !== false) { $nextCode .= $str[++$offset]; if (strpos('0123456789', $str[$offset + 1]) !== false) { $nextCode .= $str[++$offset]; } } $outEntries[] = chr(octdec($nextCode)); } else { $outEntries[] = $str[$offset]; } break; } $offset++; } } return implode($outEntries); } }

/* @source /library/Zend/Pdf/Element/Array.php */
class Zend_Pdf_Element_Array extends Zend_Pdf_Element { public $items; public function __construct($val = null) { $this->items = new ArrayObject(); if ($val !== null && is_array($val)) { foreach ($val as $element) { if (!$element instanceof Zend_Pdf_Element) { throw new Zend_Pdf_Exception('Array elements must be Zend_Pdf_Element objects'); } $this->items[] = $element; } } else if ($val !== null){ throw new Zend_Pdf_Exception('Argument must be an array'); } } public function __get($property) { throw new Zend_Pdf_Exception('Undefined property: Zend_Pdf_Element_Array::$' . $property); } public function __set($property, $value) { throw new Zend_Pdf_Exception('Undefined property: Zend_Pdf_Element_Array::$' . $property); } public function getType() { return Zend_Pdf_Element::TYPE_ARRAY; } public function toString($factory = null) { $outStr = '['; $lastNL = 0; foreach ($this->items as $element) { if (strlen($outStr) - $lastNL > 128) { $outStr .= "\n"; $lastNL = strlen($outStr); } $outStr .= $element->toString($factory) . ' '; } $outStr .= ']'; return $outStr; } public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { $newArray = new self(); foreach ($this->items as $key => $value) { $newArray->items[$key] = $value->makeClone($factory, $processed, $mode); } return $newArray; } public function setParentObject(Zend_Pdf_Element_Object $parent) { parent::setParentObject($parent); foreach ($this->items as $item) { $item->setParentObject($parent); } } public function toPhp() { $phpArray = array(); foreach ($this->items as $item) { $phpArray[] = $item->toPhp(); } return $phpArray; } }

/* @source /library/Zend/Pdf/Element/Dictionary.php */
class Zend_Pdf_Element_Dictionary extends Zend_Pdf_Element { private $_items = array(); public function __construct($val = null) { if ($val === null) { return; } else if (!is_array($val)) { throw new Zend_Pdf_Exception('Argument must be an array'); } foreach ($val as $name => $element) { if (!$element instanceof Zend_Pdf_Element) { throw new Zend_Pdf_Exception('Array elements must be Zend_Pdf_Element objects'); } if (!is_string($name)) { throw new Zend_Pdf_Exception('Array keys must be strings'); } $this->_items[$name] = $element; } } public function add(Zend_Pdf_Element_Name $name, Zend_Pdf_Element $val) { $this->_items[$name->value] = $val; } public function getKeys() { return array_keys($this->_items); } public function __get($item) { $element = isset($this->_items[$item]) ? $this->_items[$item] : null; return $element; } public function __set($item, $value) { if ($value === null) { unset($this->_items[$item]); } else { $this->_items[$item] = $value; } } public function getType() { return Zend_Pdf_Element::TYPE_DICTIONARY; } public function toString($factory = null) { $outStr = '<<'; $lastNL = 0; foreach ($this->_items as $name => $element) { if (!is_object($element)) { throw new Zend_Pdf_Exception('Wrong data'); } if (strlen($outStr) - $lastNL > 128) { $outStr .= "\n"; $lastNL = strlen($outStr); } $nameObj = new Zend_Pdf_Element_Name($name); $outStr .= $nameObj->toString($factory) . ' ' . $element->toString($factory) . ' '; } $outStr .= '>>'; return $outStr; } public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { if (isset($this->_items['Type'])) { if ($this->_items['Type']->value == 'Pages') { return new Zend_Pdf_Element_Null(); } if ($this->_items['Type']->value == 'Page' && $mode == Zend_Pdf_Element::CLONE_MODE_SKIP_PAGES ) { return new Zend_Pdf_Element_Null(); } } $newDictionary = new self(); foreach ($this->_items as $key => $value) { $newDictionary->_items[$key] = $value->makeClone($factory, $processed, $mode); } return $newDictionary; } public function setParentObject(Zend_Pdf_Element_Object $parent) { parent::setParentObject($parent); foreach ($this->_items as $item) { $item->setParentObject($parent); } } public function toPhp() { $phpArray = array(); foreach ($this->_items as $itemName => $item) { $phpArray[$itemName] = $item->toPhp(); } return $phpArray; } }

/* @source /library/Zend/Pdf/Element/Stream.php */
class Zend_Pdf_Element_FakeStream { function __construct($value){ $this->value = $value; } function & getRef() { return $this->value; } function touch() {} } class Zend_Pdf_Element_Stream extends Zend_Pdf_Element { public $value; public function __construct($val) { $this->value = new Zend_Pdf_Element_FakeStream($val); } public function getType() { return Zend_Pdf_Element::TYPE_STREAM; } public function length() { return strlen($this->value->getRef()); } public function clear() { $ref = &$this->value->getRef(); $ref = ''; $this->value->touch(); } public function append($val) { $ref = &$this->value->getRef(); $ref .= (string)$val; $this->value->touch(); } public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { return new self($this->value->getRef()); } public function toString($factory = null) { return "stream\n" . $this->value->getRef() . "\nendstream"; } }

/* @source /library/Zend/Pdf/Annotation/Text.php */
class Zend_Pdf_Annotation_Text extends Zend_Pdf_Annotation { public function __construct(Zend_Pdf_Element $annotationDictionary) { if ($annotationDictionary->getType() != Zend_Pdf_Element::TYPE_DICTIONARY) { throw new Zend_Pdf_Exception('Annotation dictionary resource has to be a dictionary.'); } if ($annotationDictionary->Subtype === null || $annotationDictionary->Subtype->getType() != Zend_Pdf_Element::TYPE_NAME || $annotationDictionary->Subtype->value != 'Text') { throw new Zend_Pdf_Exception('Subtype => Text entry is requires'); } parent::__construct($annotationDictionary); } public static function create($x1, $y1, $x2, $y2, $text) { $annotationDictionary = new Zend_Pdf_Element_Dictionary(); $annotationDictionary->Type = new Zend_Pdf_Element_Name('Annot'); $annotationDictionary->Subtype = new Zend_Pdf_Element_Name('Text'); $rectangle = new Zend_Pdf_Element_Array(); $rectangle->items[] = new Zend_Pdf_Element_Numeric($x1); $rectangle->items[] = new Zend_Pdf_Element_Numeric($y1); $rectangle->items[] = new Zend_Pdf_Element_Numeric($x2); $rectangle->items[] = new Zend_Pdf_Element_Numeric($y2); $annotationDictionary->Rect = $rectangle; $annotationDictionary->Contents = new Zend_Pdf_Element_String($text); return new Zend_Pdf_Annotation_Text($annotationDictionary); } }

/* @source /library/Zend/Pdf/Destination/FitBoundingBoxVertically.php */
class Zend_Pdf_Destination_FitBoundingBoxVertically extends Zend_Pdf_Destination_Explicit { public static function create($page, $left) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('FitBV'); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($left); return new Zend_Pdf_Destination_FitBoundingBoxVertically($destinationArray); } public function getLeftEdge() { return $this->_destinationArray->items[2]->value; } public function setLeftEdge($left) { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Numeric($left); return $this; } }

/* @source /library/Zend/Pdf/Element/Numeric.php */
class Zend_Pdf_Element_Numeric extends Zend_Pdf_Element { public $value; public function __construct($val) { if ( !is_numeric($val) ) { throw new Zend_Pdf_Exception('Argument must be numeric'); } $this->value = $val; } public function getType() { return Zend_Pdf_Element::TYPE_NUMERIC; } public function toString($factory = null) { if (is_integer($this->value)) { return (string)$this->value; } $prec = 0; $v = $this->value; while (abs( floor($v) - $v ) > 1e-10) { $prec++; $v *= 10; } return sprintf("%.{$prec}F", $this->value); } }

/* @source /library/Zend/Pdf/Destination/FitBoundingBox.php */
class Zend_Pdf_Destination_FitBoundingBox extends Zend_Pdf_Destination_Explicit { public static function create($page) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('FitB'); return new Zend_Pdf_Destination_FitBoundingBox($destinationArray); } }

/* @source /library/Zend/Pdf/Destination/FitRectangle.php */
class Zend_Pdf_Destination_FitRectangle extends Zend_Pdf_Destination_Explicit { public static function create($page, $left, $bottom, $right, $top) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('FitR'); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($left); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($bottom); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($right); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($top); return new Zend_Pdf_Destination_FitRectangle($destinationArray); } public function getLeftEdge() { return $this->_destinationArray->items[2]->value; } public function setLeftEdge($left) { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Numeric($left); return $this; } public function getBottomEdge() { return $this->_destinationArray->items[3]->value; } public function setBottomEdge($bottom) { $this->_destinationArray->items[3] = new Zend_Pdf_Element_Numeric($bottom); return $this; } public function getRightEdge() { return $this->_destinationArray->items[4]->value; } public function setRightEdge($right) { $this->_destinationArray->items[4] = new Zend_Pdf_Element_Numeric($right); return $this; } public function getTopEdge() { return $this->_destinationArray->items[5]->value; } public function setTopEdge($top) { $this->_destinationArray->items[5] = new Zend_Pdf_Element_Numeric($top); return $this; } }

/* @source /library/Zend/Pdf/Destination/Unknown.php */
class Zend_Pdf_Destination_Unknown extends Zend_Pdf_Destination_Explicit { }

/* @source /library/Zend/Pdf/Destination/Named.php */
class Zend_Pdf_Destination_Named extends Zend_Pdf_Destination { protected $_nameElement; public function __construct(Zend_Pdf_Element $resource) { if ($resource->getType() != Zend_Pdf_Element::TYPE_NAME && $resource->getType() != Zend_Pdf_Element::TYPE_STRING) { throw new Zend_Pdf_Exception('Named destination resource must be a PDF name or a PDF string.'); } $this->_nameElement = $resource; } public static function create($name) { return new Zend_Pdf_Destination_Named(new Zend_Pdf_Element_String($name)); } public function getName() { return $this->_nameElement->value; } public function getResource() { return $this->_nameElement; } }

/* @source /library/Zend/Pdf/Element/Object.php */
class Zend_Pdf_Element_Object extends Zend_Pdf_Element { protected $_value; protected $_objNum; protected $_genNum; protected $_factory; public function __construct(Zend_Pdf_Element $val, $objNum, $genNum, Zend_Pdf_ElementFactory $factory) { if ($val instanceof self) { throw new Zend_Pdf_Exception('Object number must not be an instance of Zend_Pdf_Element_Object.'); } if ( !(is_integer($objNum) && $objNum > 0) ) { throw new Zend_Pdf_Exception('Object number must be positive integer.'); } if ( !(is_integer($genNum) && $genNum >= 0) ) { throw new Zend_Pdf_Exception('Generation number must be non-negative integer.'); } $this->_value = $val; $this->_objNum = $objNum; $this->_genNum = $genNum; $this->_factory = $factory; $this->setParentObject($this); $factory->registerObject($this, $objNum . ' ' . $genNum); } public function getFactory() { return $this->_factory; } public function getType() { return $this->_value->getType(); } public function getObjNum() { return $this->_objNum; } public function getGenNum() { return $this->_genNum; } public function toString($factory = null) { if ($factory === null) { $shift = 0; } else { $shift = $factory->getEnumerationShift($this->_factory); } return $this->_objNum + $shift . ' ' . $this->_genNum . ' R'; } public function dump(Zend_Pdf_ElementFactory $factory) { $shift = $factory->getEnumerationShift($this->_factory); return $this->_objNum + $shift . " " . $this->_genNum . " obj \n" . $this->_value->toString($factory) . "\n" . "endobj\n"; } public function __get($property) { return $this->_value->$property; } public function __set($property, $value) { $this->_value->$property = $value; } public function __call($method, $args) { return call_user_func_array(array($this->_value, $method), $args); } public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { $id = spl_object_hash($this); if (isset($processed[$id])) { return $processed[$id]; } $processed[$id] = $clonedObject = $factory->newObject(new Zend_Pdf_Element_Null()); $clonedObject->_value = $this->_value->makeClone($factory, $processed, $mode); if ($clonedObject->_value instanceof Zend_Pdf_Element_Null) { unset($processed[$id]); return $clonedObject->_value; } return $clonedObject; } public function touch() { $this->_factory->markAsModified($this); } public function getObject() { return $this; } public function cleanUp() { $this->_value = null; } public function toPhp() { return $this->_value->toPhp(); } }

/* @source /library/Zend/Pdf/Element/Null.php */
class Zend_Pdf_Element_Null extends Zend_Pdf_Element { public $value; public function __construct() { $this->value = null; } public function getType() { return Zend_Pdf_Element::TYPE_NULL; } public function toString($factory = null) { return 'null'; } }

/* @source /library/Zend/Pdf/Element/Name.php */
class Zend_Pdf_Element_Name extends Zend_Pdf_Element { public $value; public function __construct($val) { settype($val, 'string'); if (strpos($val,"\x00") !== false) { throw new Zend_Pdf_Exception('Null character is not allowed in PDF Names'); } $this->value = (string)$val; } public function getType() { return Zend_Pdf_Element::TYPE_NAME; } public static function escape($inStr) { $outStr = ''; for ($count = 0; $count < strlen($inStr); $count++) { $nextCode = ord($inStr[$count]); switch ($inStr[$count]) { case '(': case ')': case '<': case '>': case '[': case ']': case '{': case '}': case '/': case '%': case '\\': case '#': $outStr .= sprintf('#%02X', $nextCode); break; default: if ($nextCode >= 33 && $nextCode <= 126 ) { $outStr .= $inStr[$count]; } else { $outStr .= sprintf('#%02X', $nextCode); } } } return $outStr; } public static function unescape($inStr) { $outStr = ''; for ($count = 0; $count < strlen($inStr); $count++) { if ($inStr[$count] != '#' ) { $outStr .= $inStr[$count]; } else { $outStr .= chr(base_convert(substr($inStr, $count+1, 2), 16, 10 )); $count +=2; } } return $outStr; } public function toString($factory = null) { return '/' . self::escape((string)$this->value); } }

/* @source /library/Zend/Pdf/Destination/FitVertically.php */
class Zend_Pdf_Destination_FitVertically extends Zend_Pdf_Destination_Explicit { public static function create($page, $left) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('FitV'); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($left); return new Zend_Pdf_Destination_FitVertically($destinationArray); } public function getLeftEdge() { return $this->_destinationArray->items[2]->value; } public function setLeftEdge($left) { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Numeric($left); return $this; } }

/* @source /library/Zend/Pdf/Destination/Zoom.php */
class Zend_Pdf_Destination_Zoom extends Zend_Pdf_Destination_Explicit { public static function create($page, $left = null, $top = null, $zoom = null) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('XYZ'); if ($left === null) { $destinationArray->items[] = new Zend_Pdf_Element_Null(); } else { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($left); } if ($top === null) { $destinationArray->items[] = new Zend_Pdf_Element_Null(); } else { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($top); } if ($zoom === null) { $destinationArray->items[] = new Zend_Pdf_Element_Null(); } else { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($zoom); } return new Zend_Pdf_Destination_Zoom($destinationArray); } public function getLeftEdge() { return $this->_destinationArray->items[2]->value; } public function setLeftEdge($left) { if ($left === null) { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Null(); } else { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Numeric($left); } return $this; } public function getTopEdge() { return $this->_destinationArray->items[3]->value; } public function setTopEdge($top) { if ($top === null) { $this->_destinationArray->items[3] = new Zend_Pdf_Element_Null(); } else { $this->_destinationArray->items[3] = new Zend_Pdf_Element_Numeric($top); } return $this; } public function getZoomFactor() { return $this->_destinationArray->items[4]->value; } public function setZoomFactor($zoom) { if ($zoom === null) { $this->_destinationArray->items[4] = new Zend_Pdf_Element_Null(); } else { $this->_destinationArray->items[4] = new Zend_Pdf_Element_Numeric($zoom); } return $this; } }

/* @source /library/Zend/Pdf/Element/Reference.php */
class Zend_Pdf_Element_Reference extends Zend_Pdf_Element { private $_ref; private $_objNum; private $_genNum; private $_context; private $_factory; public function __construct($objNum, $genNum = 0, Zend_Pdf_Element_Reference_Context $context, Zend_Pdf_ElementFactory $factory) { if ( !(is_integer($objNum) && $objNum > 0) ) { throw new Zend_Pdf_Exception('Object number must be positive integer'); } if ( !(is_integer($genNum) && $genNum >= 0) ) { throw new Zend_Pdf_Exception('Generation number must be non-negative integer'); } $this->_objNum = $objNum; $this->_genNum = $genNum; $this->_ref = null; $this->_context = $context; $this->_factory = $factory; } public function getFactory() { return $this->_factory; } public function getType() { if ($this->_ref === null) { $this->_dereference(); } return $this->_ref->getType(); } public function toString($factory = null) { if ($factory === null) { $shift = 0; } else { $shift = $factory->getEnumerationShift($this->_factory); } return $this->_objNum + $shift . ' ' . $this->_genNum . ' R'; } private function _dereference() { if (($obj = $this->_factory->fetchObject($this->_objNum . ' ' . $this->_genNum)) === null) { $obj = $this->_context->getParser()->getObject( $this->_context->getRefTable()->getOffset($this->_objNum . ' ' . $this->_genNum . ' R'), $this->_context ); } if ($obj === null ) { $this->_ref = new Zend_Pdf_Element_Null(); return; } if ($obj->toString() != $this->_objNum . ' ' . $this->_genNum . ' R') { throw new Zend_Pdf_Exception('Incorrect reference to the object'); } $this->_ref = $obj; } public function makeClone(Zend_Pdf_ElementFactory $factory, array &$processed, $mode) { if ($this->_ref === null) { $this->_dereference(); } $id = spl_object_hash($this->_ref); if (isset($processed[$id])) { return $processed[$id]; } return $this->_ref->makeClone($factory, $processed, $mode); } public function touch() { if ($this->_ref === null) { $this->_dereference(); } $this->_ref->touch(); } public function getObject() { if ($this->_ref === null) { $this->_dereference(); } return $this->_ref; } public function __get($property) { if ($this->_ref === null) { $this->_dereference(); } return $this->_ref->$property; } public function __set($property, $value) { if ($this->_ref === null) { $this->_dereference(); } $this->_ref->$property = $value; } public function __call($method, $args) { if ($this->_ref === null) { $this->_dereference(); } return call_user_func_array(array($this->_ref, $method), $args); } public function cleanUp() { $this->_ref = null; } public function toPhp() { if ($this->_ref === null) { $this->_dereference(); } return $this->_ref->toPhp(); } }

/* @source /library/Zend/Pdf/Element/Boolean.php */
class Zend_Pdf_Element_Boolean extends Zend_Pdf_Element { public $value; public function __construct($val) { if (! is_bool($val)) { throw new Zend_Pdf_Exception('Argument must be boolean.'); } $this->value = $val; } public function getType() { return Zend_Pdf_Element::TYPE_BOOL; } public function toString($factory = null) { return $this->value ? 'true' : 'false'; } }

/* @source /library/Zend/Pdf/Destination/Fit.php */
class Zend_Pdf_Destination_Fit extends Zend_Pdf_Destination_Explicit { public static function create($page) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('Fit'); return new Zend_Pdf_Destination_Fit($destinationArray); } }

/* @source /library/Zend/Pdf/Destination/FitBoundingBoxHorizontally.php */
class Zend_Pdf_Destination_FitBoundingBoxHorizontally extends Zend_Pdf_Destination_Explicit { public static function create($page, $top) { $destinationArray = new Zend_Pdf_Element_Array(); if ($page instanceof Zend_Pdf_Page) { $destinationArray->items[] = $page->getPageDictionary(); } else if (is_integer($page)) { $destinationArray->items[] = new Zend_Pdf_Element_Numeric($page); } else { throw new Zend_Pdf_Exception('Page entry must be a Zend_Pdf_Page object or a page number.'); } $destinationArray->items[] = new Zend_Pdf_Element_Name('FitBH'); $destinationArray->items[] = new Zend_Pdf_Element_Numeric($top); return new Zend_Pdf_Destination_FitBoundingBoxHorizontally($destinationArray); } public function getTopEdge() { return $this->_destinationArray->items[2]->value; } public function setTopEdge($top) { $this->_destinationArray->items[2] = new Zend_Pdf_Element_Numeric($top); return $this; } }

/* @source /library/Zend/Pdf/Color/Cmyk.php */
class Zend_Pdf_Color_Cmyk extends Zend_Pdf_Color { private $_c; private $_m; private $_y; private $_k; public function __construct($c, $m, $y, $k) { if ($c < 0) { $c = 0; } if ($c > 1) { $c = 1; } if ($m < 0) { $m = 0; } if ($m > 1) { $m = 1; } if ($y < 0) { $y = 0; } if ($y > 1) { $y = 1; } if ($k < 0) { $k = 0; } if ($k > 1) { $k = 1; } $this->_c = new Zend_Pdf_Element_Numeric($c); $this->_m = new Zend_Pdf_Element_Numeric($m); $this->_y = new Zend_Pdf_Element_Numeric($y); $this->_k = new Zend_Pdf_Element_Numeric($k); } public function instructions($stroking) { return $this->_c->toString() . ' ' . $this->_m->toString() . ' ' . $this->_y->toString() . ' ' . $this->_k->toString() . ($stroking? " K\n" : " k\n"); } public function getComponents() { return array($this->_c->value, $this->_m->value, $this->_y->value, $this->_k->value); } }

/* @sourc